<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Crypto Task 1</title>
      <link href="/2018/12/21/Crypto-Task-1/"/>
      <url>/2018/12/21/Crypto-Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也是采取任务发布的形式，每周保证上交一次任务完成报告，组织一次在线交流，通过积分制来进行最后的评测，昨天是第一次任务的截止时间，效果上并不理想，看今晚在线交流的情况再做调整。如果不愿意花时间去学习，是永远出不来成绩的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本次任务选取的是Cryptopal的Set1.1-1.3，难度很小，适合入门，编程小白稍微花点时间就应该可以看的懂。另外，附上“南宁市网络安全竞赛“的两道密码题。</p><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set 1"></a>Set 1</h2><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><p><img src="https://i.imgur.com/jiQrNFF.jpg" alt=""><br>挑战1 目的是将十六进制（hex）进行base64加密<br>所给的字符串为</p><pre><code>49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d</code></pre><p>经过base64后的输出应为</p><pre><code>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</code></pre><hr><p><strong>新手不要依赖于在线网站和工具！！！这不利于理解原理并掌握其思想，若你想做一个无脑的脚本小子，那么请继续吧！</strong></p><p>重所周知anaconda中已经集成好了很多模块，其中就包括base64，直接import就好</p><p><strong>exp1</strong></p><pre><code># -*- coding: UTF-8 -*-import base64string_hex = &apos;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&apos;# 将十六进制编码的字符进行解码string = string_hex.decode(&apos;hex&apos;)print string# 进行base64加密string_base = base64.b64encode(string)print &apos;result :&apos; + string_base</code></pre><p>具体的细节操作要自己写一遍，细细体会编程中要注意的地方，怎样更贴近人意</p><p><strong>进一步加强</strong></p><p>上述代码还是不能让我们很好的理解base64的过程，因此可以进一步扩展去了解下base64，然后自己写一个本地的base64模块。</p><p><a href="http://www.cnblogs.com/diligenceday/p/6002382.html" target="_blank" rel="noopener">base64详解</a></p><p><strong>local_base64.py</strong></p><pre><code># -*- coding: UTF-8 -*-import stringbase64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &apos;+/&apos;def encode(string):    base64_bin = [&apos;{:0&gt;8}&apos;.format(str(bin(ord(b))).replace(&apos;0b&apos;, &apos;&apos;)) for b in string]    result = &apos;&apos;    nums = len(base64_bin) // 3    remain = len(base64_bin) % 3    integral_part = base64_bin[0:3 * nums]    while integral_part:        tmp_part = &apos;&apos;.join(integral_part[0:3])        tmp_part = [int(tmp_part[x: x + 6], 2) for x in [0, 6, 12, 18]]        result += &apos;&apos;.join([base64_charset[i] for i in tmp_part])        integral_part = integral_part[3:]    if remain:        remain_part = &apos;&apos;.join(base64_bin[3 * nums:]) + (3 - remain) * &apos;0&apos; * 8        tmp_part = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]        result += &apos;&apos;.join([base64_charset[i] for i in tmp_part]) + (3 - remain) * &apos;=&apos;    return resultdef decode(string):    if not valid_base64_str(string):        return &apos;&apos;    base64_bin = [&apos;{:0&gt;6}&apos;.format(str(bin(base64_charset.index(s))).replace(&apos;0b&apos;, &apos;&apos;)) for s in string if s != &apos;=&apos;]    result = &apos;&apos;    nums = len(base64_bin) // 4    remain = len(base64_bin) % 4    integral_part = base64_bin[0:4 * nums]    while integral_part:        tmp_unit = &apos;&apos;.join(integral_part[0:4])        tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]        result += &apos;&apos;.join([chr(i) for i in tmp_unit])        integral_part = integral_part[4:]    if remain:        remain_part = &apos;&apos;.join(base64_bin[nums * 4:])        tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]        result += &apos;&apos;.join([chr(i) for i in tmp_unit])    return resultdef valid_base64_str(b_str):    if len(b_str) % 4:        return False    for m in b_str:        if m not in base64_charset + &apos;=&apos;:            return False    return Trueif __name__ == &apos;__main__&apos;:    s = &apos;ABC&apos;    s_encode = encode(s)    s_decode = decode(s_encode)    print s_encode    print    print s_decode</code></pre><p><strong>exp2</strong></p><pre><code># -*- coding: UTF-8 -*-import local_base64string_hex = &apos;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&apos;string = string_hex.decode(&apos;hex&apos;)print stringstring_base = local_base64.encode(string)print &apos;result :&apos; + string_base</code></pre><p>经过challenge1应该就能够对base64有一个很详细的了解了，还是要自己亲身尝试下才能真正掌握并转化成自己的东西。</p><h3 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h3><p><img src="https://i.imgur.com/GRIqD3Y.jpg" alt=""></p><p>挑战2 目的是让你编写一个函数，使得当你输入</p><pre><code>1c0111001f010100061a024b53535009181c</code></pre><p>让上述字符串，与下列字符串进行异或（XOR）运算</p><pre><code>686974207468652062756c6c277320657965</code></pre><p>得到的结果应该为</p><pre><code>746865206b696420646f6e277420706c6179</code></pre><hr><p>只需要进行一个异或运算，感觉起来应该不难，让我们先来了解下XOR运算操作</p><p><a href="https://blog.csdn.net/xiaopihaierletian/article/details/78162863" target="_blank" rel="noopener">逻辑运算详解</a></p><p>通过上述运算原理的介绍，可以看出这道题目就是等长度异或，实现起来很容易</p><p><strong>exp</strong></p><pre><code># -*- coding: UTF-8 -*-string_hex = &apos;1c0111001f010100061a024b53535009181c&apos;string = int(string_hex,16)string_xor = &apos;686974207468652062756c6c277320657965&apos;string_xor = int(string_xor,16)string_result = string ^ string_xorstring_result = hex(string_result)print &apos;result :&apos; + string_result[2:-1]</code></pre><h3 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge 3"></a>Challenge 3</h3><p><img src="https://i.imgur.com/hkCqCx1.jpg" alt=""></p><p>挑战3 题意是给定的下列字符串</p><pre><code>1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736</code></pre><p>是明文与某个单字符异或得到的，让我们找到密钥，并解密出明文的内容</p><p>可以手工完成，但请不要：请编写代码完成</p><hr><p>既然是编写函数，那必然要了解python中的def</p><p><a href="https://www.cnblogs.com/derezzed/articles/8119592.html" target="_blank" rel="noopener">python中的def</a></p><p>先不考虑评分标准，要先找到那个单字符<br>回想一下ascii码中一共有256个，虽然一个一个尝试对于人来说比较缓慢，但对于计算机来说应该不到一秒钟的事。所以这里决定来进行遍历尝试，也就是俗称的“暴力破解”</p><p><strong>暴力破解模块</strong></p><pre><code>def brute(string_xor):    score_pre = 0    for i in range(128):        result = &apos;&apos;        for j in re.findall(&apos;.{2}&apos;,string_xor):            k = int(j,16)            r = chr(i ^ k)            result += r</code></pre><p>这样的话，256种结果都会被存储到result中，接下来解决打分的问题，只需要对每个result进行个测评，然后比较下输出最高的就好了。</p><p><strong>exp</strong></p><pre><code># -*- coding: UTF-8 -*-import restring_xor = &apos;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&apos;def judge(s):    score_tmp = 0    freqs = {&apos;a&apos;:0.0651738,&apos;b&apos;:0.0124248,&apos;c&apos;:0.0217339,&apos;d&apos;:0.0349835,         &apos;e&apos;:0.1041442,&apos;f&apos;:0.0197881,&apos;g&apos;:0.0158610,&apos;h&apos;:0.0492888,         &apos;i&apos;:0.0558094,&apos;j&apos;:0.0009033,&apos;k&apos;:0.0050529,&apos;l&apos;:0.0331490,         &apos;m&apos;:0.0202124,&apos;n&apos;:0.0564513,&apos;o&apos;:0.0596302,&apos;p&apos;:0.0137645,         &apos;q&apos;:0.0008606,&apos;r&apos;:0.0497563,&apos;s&apos;:0.0515760,&apos;t&apos;:0.0729357,         &apos;u&apos;:0.0225134,&apos;v&apos;:0.0082903,&apos;w&apos;:0.0171272,&apos;x&apos;:0.0013692,         &apos;y&apos;:0.0145984,&apos;z&apos;:0.0007836,&apos; &apos;:0.1918182         }    for x in s.lower():        if x in freqs:            score_tmp += freqs[x]    return score_tmpdef brute(string_xor):    score_pre = 0    for i in range(128):        result = &apos;&apos;        for j in re.findall(&apos;.{2}&apos;,string_xor):            k = int(j,16)            r = chr(i ^ k)            result += r        score = judge(result)        if score &gt; score_pre:            score_pre = score            final = result            key = chr(i)    return final,keyfinal,key = brute(string_xor)print finalprintprint key</code></pre><p>这里是字母采用频率的方法进行测评，python3中带有wordfreq模块直接可以查取字符频率，无奈使用的是python2，只能采用其他人收集的频率情况。</p><h2 id="南宁市网络安全技术大赛（Crypto）"><a href="#南宁市网络安全技术大赛（Crypto）" class="headerlink" title="南宁市网络安全技术大赛（Crypto）"></a>南宁市网络安全技术大赛（Crypto）</h2><p>writeup分享者：Mengmeng</p><h3 id="维吉尼亚遇上困难"><a href="#维吉尼亚遇上困难" class="headerlink" title="维吉尼亚遇上困难"></a>维吉尼亚遇上困难</h3><p>密文：<br>BZGTNPMMCGZFPUWJCUIGRWXPFNLHZCKOAPGLKYJNRAQFIUYRAVGNPANUMDQOAHMWTGJDXGOMPJPTKAAVZIUIWKVTUCWBWNFWDFUMPJWPMQGPTNWXTSDPLPMWJAXUHHXWPFXXGVAPFNTXVFKOYIRBOQJHCBVWVFYCGQFGUSUBDWVIYATJGTBNDKGHCTMTWIUEFJITVUGJHHIMUVJICUWYQWYGGUWPUUCWIFGWUANILKPHDKOSPJTTWJQOJHXLBJAPZHVQWPDYPGLLGDBCHTGIZCCMEGVIIJLIFFBHSMEGUJHRXBOQUBDNASPEUCWNGWSNWXTSDPLPMWJAIUHUMWPSYCTUWFBMIAMKVBNTDMQNBVDKILQSSDYVWVXIGDQFIBHSLEAVDBXGOLGDBCHTGIZVNFQFKTNGRWXUDCTGKWCOXIXKZPPFDZGXNBAXLGGWBLTLWCKOXAR</p><p>题目已经给出很明显的提示了，是维吉尼亚密码，根据密文的长度，可以确定是想让我们进行无密钥破解维吉尼亚密码，原理如下：</p><p><a href="https://blog.csdn.net/limisky/article/details/16885959" target="_blank" rel="noopener">维吉尼亚密码及其破解原理</a></p><p>用github上的工具，跑一下,得到flag<br><img src="https://i.imgur.com/QMFAvbz.png" alt=""></p><p><a href="https://atomcated.github.io/Vigenere/" target="_blank" rel="noopener">维吉尼亚无密钥破解工具</a></p><p>该工具可以直接下载下来，部署到本地</p><p>flag:{YOU ARE SO KINDLY}</p><h3 id="shamir重要数据损坏"><a href="#shamir重要数据损坏" class="headerlink" title="shamir重要数据损坏"></a>shamir重要数据损坏</h3><p>该题目考查的是Shamir秘密共享算法</p><p> <img src="https://i.imgur.com/KyHYt6N.png" alt=""></p><p> 大概了解了之后用题目给的信息进行计算<br> <img src="https://i.imgur.com/INN4jMu.png" alt=""></p><p> X1=5，X2=7，X3=9</p><p>（X_1,f(X_1)）=(5,2258)</p><p>（X_2,f(X_2)）=(7,2424)</p><p>（X_3,f(X_3)）=(9,2630)</p><hr><p>a0+a_1 x_1+a_2 x_1^2=2258</p><p>a0+a_1 x_2+a_2 x_2^2=2424</p><p>a0+a_1 x_3+a_2 x_3^2=2630</p><p>代入x1,x2,x3,经计算可得a0=2018，a1=23,a2=5<br>所以s=a0=2018<br>flag：{2018}</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>对于小白来讲，可能会觉得这些东西有点晦涩。但我想说的是，这仅仅只是个入门，至今为止我都坚信一万个小时定律，这段时间的锤炼是让你从平凡变成大师的过程，若是能踏踏实实走完，想必你不会后悔，我会伴随你们一同前行，加油我们的信安之路！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello my New World</title>
      <link href="/2018/12/20/Hello-my-New-World/"/>
      <url>/2018/12/20/Hello-my-New-World/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天给萌萌尝试着搭建了这个博客，花了差不多半天的时间，部分功能还没调试完成，总的来说界面很清新，我倒是蛮喜欢的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这次更新了之后，就应该不会再进行大的变动了，也是时隔一段时间没有更新博客了。<br>原因是前一段时间满课，周末在忙着比赛，基本上是天天加班，顺着带着也记录下这段时间的经历吧</p><p>“领航杯”之后应该一直都是满课的，从早上到晚。对于课程的安排我反正是无力吐槽了，身为一名大四的信安专业学生，却在课堂上一点专业知识都学不到。</p><p>“东华杯”的线上赛发挥还是挺好的，拿下了一道密码二血，跟着蒋师傅把战队总到了决赛，可惜决赛那周周末比赛较多，少了一次线下比赛的机会。转身去打了X-nuca全国高校联赛。</p><p>X-nuca是在厦门打的，是作为“博鹭杯”同行去厦门的，虽说是同行不用上场，但X-nuca的线上同样至关重要，只有我和蒋师傅两个人参加，可以说线上打得是十分难受了，从头至尾我这个密码+三流web手只解出了一道题目，最后还是靠着徐教员的帮忙，才挺进了决赛。还是自己太菜了。。</p><p>“鹏城杯”的线上赛还是蛮轻松的，密码题拿了个一血，misc和web也是在何师傅的指导下出了几道题目，最后凭着一个不错的名次进入了决赛</p><p>X-nuca和“鹏城杯”的线下赛是我今年成长最大的一次。也正是这两场比赛真正地打醒了我这只菜鸡。。满场纷飞的pwn题打得我没脾气。由于主办方的失误有幸让我们提前拿到了源码，虽说分析了一波写出了exp，但在服务器上线的时候，瞬间就被打到绝望。</p><p>赛后打听到，牛*的大佬队伍都是本地跑好了连接ssh，down源码的脚本，就算单身二十年的手速同样是追不上计算机的脚步啊。。。跟神仙们的差距太大了，不论是思路还是技术都很落后，现在早已不是闭关修炼二十年出山就能当老大的时代了。</p><p>本事是自己的，我不甘心做一只井底之蛙。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
