<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Wi-Fi基本知识学习</title>
      <link href="/2019/01/05/Wi-Fi%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/05/Wi-Fi%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><h2 id="有线和无线网络"><a href="#有线和无线网络" class="headerlink" title="有线和无线网络"></a>有线和无线网络</h2><p>目前，有线网络中最著名的是以太网（Ethenet），但是无线网络WLAN是一个很有前景的发展领域，虽然不会完全取代以太网，但是随着便携式的发展，它会拥有越来越多的用户，无线网络中最有前景的就是Wi-Fi技术。</p><p>无线网络相比有线网络，还是有很多不足的</p><ol><li>通信双方因为是通过无线进行通信，所以通信前需要建立连接；而有线网络就直接使用线缆连接，就不需要这个过程了。</li><li>通信双方通信方式是半双工的通信方式；而有线网络可以全双工</li><li>通信时在网络层一下出错的概率非常高，所以帧的重传概率很大，需要在网络层之下的协议添加重传机制（不能只依赖于上层TCP/IP的延时等待重传等来保证）；而有线网络出错概率非常小，无需在网络层有如此复杂的机制。</li><li>数据是在无线环境下进行的，所以抓包很容易，存在安全隐患</li><li>因为收发无线信号，所以功耗很大，对电池要求较大</li><li>相对有线网络吞吐量低，这一点正在逐步改善，802.11n协议可达600Mbps的吞吐量。</li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Ethenet和Wi-Fi采用的协议都属于IEEE802协议集。其中，Ethenet以802.3协议做为其网络层以下的协议；而Wi-Fi以802.11做为其网络层以下的协议。无论是有线网络，还是无线网络，其网络层以上的部分，基本一样。</p><p>这里主要关注下Wi-Fi网络中相关的问题。Wi-Fi的802.11协议包含许多子部分。其中按照时间顺序发展，主要有：</p><ol><li>802.11a，1999年9月制定，工作在5GHz的频率范围（频段宽度325MHz），最大传输速率54mbps。</li><li>802.11b，1999年9月制定，时间比802.11a稍晚，工作在2.4G的频率范围（频段宽度83.5MHz），最大传输速率11mbps。</li><li>802.11g，2003年6月制定，工作在2.4GHz频率范围（频段宽度83.5MHz），最大传输速率54mbps。</li><li>802.11n，2009年发布，在2.4GHz和5GHz均可工作，最大传输速率为600mbps</li></ol><p>这些协议均为无线网络的通信所需的基本协议，最新发展的，一般要比最初的有所改进。</p><p>另外值得注意的是，802.11n在MAC层进行了一些重要的改进，所以导致网络性能有了很大的提升，比如：</p><ol><li><p>因为传输速率很大程度上取决于Channel（信道）的ChannelWidth有多宽，而802.11n协议中采用了一种新技术，可以在传输数据时，将两个信道合并为一个进行传输，这样极大地提高了传输速率（又称HT-40，high through）</p></li><li><p>802.11n的MIMO（多输入输出）特性，使得两对天线可以在同时同Channel上进行传输数据，而两者却能够不互相干扰（采用了OFDM特殊的调制技术）</p></li></ol><p>以上更新于2018年1月5日….</p><hr><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>讲述之前，我们需要对无线网络中一些常用的术语有所了解。这里先列出一些，后面描述中出现的新的术语，将会在描述中解释。</p><ol><li>LAN：即局域网，是路由和主机组成的内部局域网，一般为有线网络</li><li>WAN：即广域网，是外部一个更大的局域网</li><li>WLAN（Wireless LAN，即无线局域网）：前面我们说的LAN是局域网，更多指的的是有线网络中的局域网，无线网络中的局域网，一般用WLAN</li><li>AP（Access Point的简称，即访问点，接入点）：是一个无线网络中的其他类型节点，可以和无线网络外部以及内部进行通信。一般AP和无线路由都在一台设备上。</li><li>Station（工作站）：表示连接到无线网络中的设备，这些设备通过AP，可以和内部其他设备或无线网络外部通信。</li><li>Associate（连接）：如果一个Station想要加入到无线网络中，需要和这个无线网络中的AP关联（即Associate）</li><li>SSID：用来标识一个无线网络，后面会详细介绍，我们这里只需了解，每个无线网络都有它自己的SSID。</li><li>BSS（Basic Service Set）：由一组相互通信的工作站组成，是802.11无线网络的基本组件。主要有两种类型：IBSS和基础结构型网络。IBSS又叫ADHOC，组网是临时的，通信方式为Station<->Station；基础结构型网络，其通信方式是Station<->AP<->Station，也就是所有无线网络中的设备想要通信，都要经过AP。在无线网络的基础型网络中嘛，最重要的两种设备：AP和Station。</-></-></-></li><li>BSSID：用来标识一个BSS，其格式和MAC地址一样，是48位的地址格式。一般来说，它就是所处的无线接入点的MAC地址。某种程度来说，他的作用和SSID类似，但是SSID是网络的名字，是给人看的。BSSID是给机器看的，BSSID类似MAC地址。</li><li>DS（Distributed System）：即分布式系统。分布式系统属于802.11逻辑组件，负责将帧转发至目的地址，802.11并未规定其技术细节，大多数商业产品以桥接引擎和分布式系统媒介共同构成分布式系统。分布式系统是接入点之间转发帧的骨干网络，一般是以太网。其实，骨干网络并不是分布系统的全部，而是其媒介。主要有三点：骨干网（例如以太网）、桥接器（具有有线无线两个网络接口的接入点）、属于骨干网上的接入点所管辖的基础型网络的station通信（和外界或者BSS内部的station）</li></ol><p>以上更新于1月6日….</p><h1 id="实践基础"><a href="#实践基础" class="headerlink" title="实践基础"></a>实践基础</h1><h2 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h2><ol><li>MAC：MAC（即Media Access Control，介质访问控制），是数据链路层的一部分。MAC地址是烧录在NetworkInterfaceCard（即网卡，NIC）里的，他也叫硬件地址，是由48位（即bit，一字节为8位，即1byte=8bits）16进制的数字组成。其中0-23位叫做组织唯一标志符（Orgnizationnally unique，简称OUI），是识别LAN（局域网）节点的标识（在有些抓包工具抓包的时候会将前三个字节映射成某种组织名称的自负，也可以选择不显示这种映射），24-47位是由厂家自己进行分配。</li><li><p>SSID：表示一个子网的名字，无线路由通过这个名字可以为其他设备标识这个无线路由的子网。设备进行扫描的时候，就会将相应的SSID扫描到，然后就能够选择相应的SSID连接到相应的无线网络（当然不扫描，理论上也可以直接指定自己事先已经知道的SSID进行连接）。SSID允许存在重复，这样在扫描的时候会看到两个同样的SSID无线网络，其实这一般用于将一个无线网络扩大的情况（毕竟无线路由器无线信号的覆盖范围是有限的）：当想要扩大一个无线网络（即SSID固定）的范围的时候，可以给多个路由设置相同的SSID来达到这个目的。（这也是漫游的原理，漫游的时候，我们可以在远方或者本地都能打电话，也就是访问移动通信网络）。</p><p> SSID和BSSID不一定一一对应，一个BSSID在不同的Channel上面可能会对应多个SSID，但是他们在一个Channel上是一一对应的；另外，漫游的时候，虽然SSID不变，但是BSSID一定是会变化的。我们经常可以看到实际数据包中AP的MAC地址和BSSID只差几位，其实实际设备的MAC地址可能只有一个，和BSSID没什么对应关系。在一个包含了路由功能和AP功能的无线路由器（Fat AP）上面，很可能是：路由器有两个MAC地址，一个用于外网（WAN），一个用于内网（WLAN和LAN），一般路由器上面或者或者配置路由器的网页上面只标注外网的MAC地址；内网的MAC地址和外网MAC地址一般只有几位不同（甚至连续，也有些相差很多的例外）。</p></li><li>Band（频率范围）：一般AP可以支持5G或2.4G两个频率范围段的无线信号。如果两者同时可以设置，而不是互斥，那么这个路由器还能够同时支持两种频段（频段即为Band），这相当于这个AP可以建立两个无线网络，他们采用不同的频段（这类似收音机在长波范围内收音和短波范围内收音）。</li><li>Channel（信道）：Channel是对频段的进一步划分（将5G或者2.4G的频段范围再划分为几个小的频段，每个频段称作一个Channel）。处于不同传输信道上面的数据，如果信道覆盖范围没有重叠，那么不会相互干扰。对于信道的使用，在国际上有所规定。其中有些信道是无需授权即可使用的（究竟是哪个频段的信道，依照各个国家而不同），无需授权使用的意思是，传输数据的时候（无论以哪种无线方式），可以让设备收发的功率导致传输时的数据进入该信道的频率并在该信道所在频段宽度内进行传输；授权使用的意思是，不允许使用授权信道进行传输，否则会违反规定，并且干扰信道上其他数据的传输。另外，除了Wi-Fi，微波、红外线、蓝牙（使用802.15协议）的工作频段也都有在2.4GHz范围内的，所以他们传输的时候会对Wi-Fi传输造成干扰，因为两者在不同的协议下进行通信，所以互相将对方传输的信号识别为噪声。有时候配置AP的时候，Channel中有一个类似“Auto”的选项值，这表示打开AP的时候，AP自己Scan周围的环境，选择一个干扰最小的Channel来进行通信，当选择好了一个Channel的时候，一般就不会改变了。</li><li><p>Channel Width（信道宽度）：这里的Channel Width是信道的带宽，有“20MHz”、“40MHz”等，它表示一个Channel片段的宽度（假设5G的频段宽度总共为100M，平均划分为互不干扰的10个Channel，那么每个Channel的Channel Width就为100M/10=10M，实际Channel并不一定是不重叠的）。这个参数可能依赖于一些其他的选项，例如不是802.11协议，就不可能会有40MHz的Channel Width（N模式有一个特点就是可以把两个Channel合并，通过提高Channel Width来提高吞吐量）。例如选择了“20MHz”这个Channel Width之后，后面再选择一个“5.18GHz”的Channel，则表示以5.18GHz为中心的前“10MHz”以及其后面的“10MHz”频带范围被占用。</p><p> 至此可知，配置无线AP的时候，如果屋子里面有很多AP（也就是无线路由器接入点）的话，仔细设置他们的Channel Width和Channel可以保证他们相互之间的干扰（类似收音机里面的串台）尽可能小。当然，如果互相干扰了，那么Net Mode所指定的协议也会有相应的处理方式让他们之间进行协调（例如让谁先通信谁等一会儿再通信之类的），但是这样网络的性能就不如没有干扰的时候好了。</p></li><li>Wireless Security（无线网络的安全性）：这里主要涉及WEP、WPA、WPA2和RC4、TKIP、AES。<br> IEEE 802.11所制定的是技术性标准，Wi-Fi联盟所制定的是商业化标准，而Wi-Fi所制定的商业化标准基本上也都符合IEEE所制定的技术性标准。WEP是1999年9月通过的IEEE802.11标准的一部分；WPA(Wi-Fi Protected Access）事实上就是由Wi-Fi联盟所制定的安全性标准；而WPA2其实就是WPA的第二个版本。直观点说，WEP是较老的认证方法，它有好几个弱点，因此在2003年被WPA淘汰，WPA又在2004年由完整的IEEE802.11i标准（又称为WPA2）所取代。<br> WEP（Wired Equivalent Privacy），采用名为RC4的RSA加密技术；WPA（Wi-Fi Protected Access），采用新的TKIP算法，TKIP算法保留了RC4，所以也有其弱点，但是这个时候更好的CCMP还没完成，所以现在WPA上用TKIP技术；WPA2是WPA的第2个版本，采用CCMP加密协定（在有些路由器等设备上设定加密协定或者加密算法的时候，可能会用类似AES之类的字眼替代CCMP）。所以WPA2+AES是安全性最强的。<br> 另外，在有些无线网络设备的参数中会看到像WPA-Enterprise/WPA-Enterprise就是WPA/WPA2；WPA-Personal/WPA2-Personal其实就是WPA-PSK/WPA2-PSK，也就是以“pre-share key”或“passphrase”的验证（authentication）模式来代替IEEE802.1X/EAP的验证模式，PSK模式下必须使用验证服务器（例如RADIUS Server），所以特别适合家用或者SOHO的使用者。<br> 还有，wep是旧的加密方式，工作于802.11b/g模式下，而802.11n草案并不支持此加密方式，所以如果802.11n的设备采用wep加密方式后，他也只会工作在802.11b/g模式下，n的性能发挥不出来。<br> 实际中，在有些路由上面，设置的时候，可能不是严格按照这个规定来设置的（例如设定了采用WPA方式，还可以选择AES），但大体上如此。</li><li>Region（区域）：一般在无线网络中的AP上都有一个参数，表明它是处于哪个Region（地区）。Station根据AP中设置的Region调整其相应的发射功率以遵守该地区的规定。AP调整过程一般都是手动设定，设置好AP所处的Region之后，这些信息就会在AP发送的Beacon帧（后面会说到）中包含了；通过这个AP连接到无线网络上的Station，从Beacon帧中了解到这些Region信息，并且根据这些信息中的规定和AP进行通信。如果AP开始设置错了，那么Station和AP通信的时候，采用的将是不符合Region规定的频段，可能会对该Region中的其他传输网络造成干扰，这应当是“非法”的。</li><li><p>Transmission Rate（传输速率）：设置传输速率。这里采用不同的无线网络传输协议（802.11a，802.11b，802.11g等），那么可以设置的速率范围有所不同，这里的速度是指理论的速度。实际中，由于各种干扰因素，传输的速率可能会比设置的小。</p><p> 一般而言，在无线网络中，对于某种协议的性能进行描述时，我们需要注意的是，描述时提到的传输速率（Datarate）和吞吐量（Throughput）是不同的。Datarate是理论上面的最大数据传输速率，而Throughput是数据的实际最大吞吐量。因为厂家以及传输时所使用的协议等各种因素造成的开销，会导致实际吞吐量比理论吞吐量要小，一般实际最大吞吐量为理论最大的50%左右（一个不太准确但是相对直观的估计：在网络中，高清视频所需的Throughput也就30mbps左右，网络上一般的视频也就4mbps左右）</p></li></ol><p>以上更新于2018.1.16….</p>]]></content>
      
      
      
        <tags>
            
            <tag> Wi-Fi </tag>
            
            <tag> 无线基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手机WI-FI信号采集网络的设计与实现</title>
      <link href="/2018/12/28/%E6%89%8B%E6%9C%BAWI-FI%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/12/28/%E6%89%8B%E6%9C%BAWI-FI%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="手机WI-FI信号采集网络的设计与实现"><a href="#手机WI-FI信号采集网络的设计与实现" class="headerlink" title="手机WI-FI信号采集网络的设计与实现"></a>手机WI-FI信号采集网络的设计与实现</h1><p>@(VPR)[信号采集|Wi-Fi|网络|手机|大学本科毕业设计]</p><p><strong>XXXX</strong>是一种基于Esp8266开发模块的信号采集设备，其利用现代物联网热潮下的硬件亮点：“轻巧”和“灵活”两大特点为大范围采集信号奠定基础，通过探针数据的提取和mesh网络技术达到收集信号的效果，特点概述：</p><ul><li><strong>使用方便</strong> ：通过预先设置的采集算法，只要用户为设备提供电源即可；</li><li><strong>部署灵活</strong> ：通过Mesh网络的构建，可以实现轻便、高效的接力数据传输；</li><li><strong>适用性高</strong> ：采用mqtt协议，实现了数据在高延迟/带宽优先的网络上的传输；</li><li><strong>成本低廉</strong> ：Esp8266开发板本身的物理硬件成本低廉，；</li></ul><p>作者：战权海   联系方式：<a href="mailto:1137288942@qq.com" target="_blank" rel="noopener">1137288942@qq.com</a>  开始时间：2018年10月2日</p><p><strong>项目说明：</strong><br>本项目起源于学校本身的SRT，后将项目中的信号采集网络部分拆分出来作为毕业设计模块，因此会首先更新WI-FI信号采集网络部分，正巧也是该项目中的第一部分，也是最基础，最基层的部分，该项目的好坏直接影响着后续工作的发展。</p><p><strong>更新在2018年11月10日</strong><br>根据导师前段时间的介绍交流，对项目情况作出如下了解：<br>1.该采集网络要基于esp8266开发板，其资料主要参考乐鑫公司产品说明<br>2.已采购四博智联的断网神器、Wi-Fi探针普通版及http上传版，准备采集源码随后进行分析<br>3.已采购W32集成开发板，着手在空板子上实行代码<br>4.该网络主要基于mqtt网络协议</p><pre><code>并于当日撰写开题报告</code></pre><p><strong>更新在2018年11月17日</strong><br>由于上周一直在忙着考试复习，没有时间关注毕设的事情，下周二要进行开题答辩，因此要进行好好准备</p><p><strong>更新在2018年11月27日</strong><br>最近一直在忙于CTF比赛，今天终于有时间静下心来好好研究项目，但是一上来就被卡住，使用Arduino开发的并不是十分顺利，使用数据线连接到电脑上，使用esptool就可以进行烧写，但是没搞懂要把程序写在哪里，使用Arduino IDE进行开发时，代码始终不能上传，很头疼，不知道怎么处理</p><p><strong>更新在2018年12月28日</strong><br>一晃又过了一个月，这个项目的进展程度确实特别的小，1月13日就要进行阶段性检查，还蛮头疼的。好在上周发现好像是esp板子型号的问题，自己重新采购了一块esp8266，昨天一次性就烧录成功。接下来要做的就是进行简单的开发，具体的mesh网络与mqtt源码已经在github上search到了，要好好学习一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
            <tag> Wi-Fi信号采集 </tag>
            
            <tag> Iot开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018网络安全攻防演练</title>
      <link href="/2018/12/27/2018%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/"/>
      <url>/2018/12/27/2018%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周六当晚接到的学院通知，匆匆忙忙回去请假，周天就要报道入住，了解了规则后，觉得这次活动的成长肯定会不少，毕竟不是比赛，没有那么大的压力，从头至尾的保密工作还是比较严格的。当然，这篇文章中不会透露任何过程中涉及的内容，仅是我个人的体会与技术分享。（ps.可能会比较枯燥）</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="我的演练过程"><a href="#我的演练过程" class="headerlink" title="我的演练过程"></a>我的演练过程</h2><p>此次活动主要是以实战网络攻击为主，依靠的是漏洞挖掘与内网渗透的技能。如果平时大佬们挖src比较多或者有很多实战经验的话应该会很得心应手。</p><p>起初的思路有点问题，想依照这awd的模式进行批量攻击，先简要过滤出可能存在的网站，然后再逐个细致挖掘。但这样操作的话，效率十分低下，扫描器的效能问题先搁置不提，单单对一个可能存在漏洞的网站进行挖掘就已经很费时间了，更不要提利用。</p><p>这里说明下，实战不同于src，讲究更多的是利用，而不是发现漏洞。举个例子，在src挖掘过程中，证明某个网站存在sql注入漏洞可以注出数据，拖库是件很了不得的事情，但在实战中，你需要注出管理员的用户名与密码，登陆进去查看能获得什么重要类型的数据，以此来表示该漏洞的威胁程度。</p><p>因此在最开始的一段时间，没有头绪，仅仅是在主域名下不断查找可能存在的漏洞点。随后初见雏形，在某个门户网站下发现了很多的管理系统，开始尝试弱口令的爆破，也是就凭着这三板斧，拿下了几个后台。但后续的利用方式显得十分鸡肋，找到了文件上传的点，但是在上传、连接的过程中经验不足，没能成功getshell。</p><p>最后面的两天基本上没能拿下啥重要的网站，一方面是自己做这方面的经验太少了，另外也是技术不够扎实不够娴熟。</p><h2 id="与大佬的经验交流"><a href="#与大佬的经验交流" class="headerlink" title="与大佬的经验交流"></a>与大佬的经验交流</h2><p>过程中，认识几位从事这方面的牛人，成绩也是十分靠前，经过交流也是学到了很多东西</p><p>在做攻击的过程中，信息搜集的部分永远都应该是花的时间最长而且最为细致的一个，这一环节在做的主要就是进行打击面的拓宽。利用搜索引擎的site、ip等功能尽可能多的获取到同源的网站。最后利用nmap进行端口的扫描，总能在其中发现一些纰漏。这样下去再进行子域名的爬去，攻击面就得到了指数级的增长。可以这样来算，同样利用弱口令，我真对一个网站只有一次攻击机会，对方经过攻击面的拓展，在同一台主机下发现了100个旁站，那么对于他拿下这台主机的次数就增加了100次。效果可想而知。</p><p>还有就是平时经验的积累，怎样绕过waf、利用怎样的文件后缀可以上传小码、大码到服务器上，怎样通过host文件过狗，这都需要长时间的经验积累，一眼就能识别编辑器的类型，想到最近爆出的某某漏洞，从而加以利用。</p><p>自动化工具，批量化工具固然好用，但是在真实的网络战场上，是不容许你去进行多次尝试的，甚至没有第二次机会。因为身为网站的维护着也不是吃素的，也是会搭载些检测警报系统与安全防护系统的。</p><p>最重要的一点写在这里，现如今网络安全法已经出台有几年了，各位师傅们大佬们还是要谨言慎行，平时开开玩笑就好了，别真的搞出来事情，敲几下键盘是小事，给别人造成麻烦与损失进了局子可就不简单了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我自认为自己入门网络安全也就刚刚一年，才疏学浅，还是很菜的，更多的时间都是在接触CTF竞赛，经过这两次的awd与实战演练，原来CTF也仅仅只是个入门。它更多的是将条件为你构造清楚，选手们去利用各种骚操作进行绕过。但在实战环境中，往往最为基础，最为简单的手法会发现更为严重的漏洞，基础和入门固然重要，小白们也请不要局限于此，专注了眼前的树叶却没看见正片森林。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018安恒杯十二月月赛-部分WriteUp</title>
      <link href="/2018/12/22/2018%E5%AE%89%E6%81%92%E6%9D%AF%E5%8D%81%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9B-%E9%83%A8%E5%88%86WriteUp/"/>
      <url>/2018/12/22/2018%E5%AE%89%E6%81%92%E6%9D%AF%E5%8D%81%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9B-%E9%83%A8%E5%88%86WriteUp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>早早的就报了名，可惜今天满课，只有中午和下午4点之后的时间打了一下比赛，pwn题是战队的大佬帮忙出的，听说蛮简单的，等Peanuts大佬更新出WriteUp我再更新学习下。总的来说月赛的题目难度较小，比较适合新手入门。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p>解压题目包，给出了两个文件</p><pre><code>-备忘录.txt-只要学不死就往死里学.zip</code></pre><p>通过解压软件可以看到在zip包中也存在“备忘录.txt“<br>这样的话，必然是已知明文攻击了</p><p><a href="http://www.cnblogs.com/leixiao-/p/9824557.html" target="_blank" rel="noopener">zip的各种攻击方式</a></p><p>这样就可以获得破解密码 <strong>1qazmko098</strong></p><p>解压得到了一个word文件</p><pre><code>-学习资料.docx</code></pre><p><img src="https://i.imgur.com/KxfXS1P.jpg" alt=""></p><p>参考这其中的方法 <a href="https://blog.csdn.net/DRondong/article/details/79322799" target="_blank" rel="noopener">word隐写方法</a></p><p>移动图片就能看到flag</p><p><img src="https://i.imgur.com/NwgyFtX.jpg" alt=""></p><h3 id="JUJU"><a href="#JUJU" class="headerlink" title="JUJU"></a>JUJU</h3><p>直接解压出一个损坏的png文件</p><pre><code>-juju.png</code></pre><p>因此先使用010editor修复下</p><p>直接跑png模板就能将CRC校验值修改过来，从而能正常打开图片</p><p>题目中提示有11只猪，但明显图片上的数目不够，因此考虑是不是要修改图片长度</p><p><a href="https://blog.csdn.net/persist213/article/details/79374914" target="_blank" rel="noopener">misc中的png隐写</a></p><p>从中可以了解到，png的宽度是不可以更改的，但是长度可以进行修改，因此稍微将长度加大，就可以在下文中看到字符串</p><p><img src="https://i.imgur.com/nq8lv5n.jpg" alt=""></p><pre><code>MZWGCZ33GQZTQMTEM5SGMMTEPU=====</code></pre><p>显然不是base64（base64最多只能有两个=）</p><p>因此考虑尝试其他base编码，经过base32解码后能看到flag</p><p><img src="https://i.imgur.com/7dpWJxF.png" alt=""></p><p>按要求将{}中的字符串md5后就是最后的答案</p><h2 id="Blockchain"><a href="#Blockchain" class="headerlink" title="Blockchain"></a>Blockchain</h2><h3 id="CoinFlip"><a href="#CoinFlip" class="headerlink" title="CoinFlip"></a>CoinFlip</h3><p>我也是第一次接触区块链的题目，也是听说晚上有原题，就搜了下然后进行了复现</p><p><a href="https://www.secpulse.com/archives/73682.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/73682.html</a></p><p><a href="http://foreversong.cn/archives/1295" target="_blank" rel="noopener">http://foreversong.cn/archives/1295</a></p><p><a href="https://remix.ethereum.org/" target="_blank" rel="noopener">https://remix.ethereum.org/</a></p><p>将.sol文件直接拖进去，按照</p><p><a href="https://www.linkedbyx.com/taskinfo/368/detail" target="_blank" rel="noopener">https://www.linkedbyx.com/taskinfo/368/detail</a></p><p>文章里的操作步骤进行复现</p><p>要注意找好对应的版本</p><p><img src="https://i.imgur.com/oFziHrn.jpg" alt=""></p><p><img src="https://i.imgur.com/78xqDhM.jpg" alt=""></p><p>最后就能到邮件中收到flag</p><p>flag{e0a8634dbb9bd36581a65ca00e2ca886}</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>凑巧今天并列第三名，拿了10w积分，才知道原来安恒的奖励力度这么高（我才不是为了奖励…）这样的话，还是要多参加一下的哈哈哈哈。写的不够到位，各位大佬可以发邮件批评指正，邮箱就在头像下方呦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安恒月赛 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Crypto Task 1</title>
      <link href="/2018/12/21/Crypto-Task-1/"/>
      <url>/2018/12/21/Crypto-Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也是采取任务发布的形式，每周保证上交一次任务完成报告，组织一次在线交流，通过积分制来进行最后的评测，昨天是第一次任务的截止时间，效果上并不理想，看今晚在线交流的情况再做调整。如果不愿意花时间去学习，是永远出不来成绩的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本次任务选取的是Cryptopal的Set1.1-1.3，难度很小，适合入门，编程小白稍微花点时间就应该可以看的懂。另外，附上“南宁市网络安全竞赛“的两道密码题。</p><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set 1"></a>Set 1</h2><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><p><img src="https://i.imgur.com/jiQrNFF.jpg" alt=""><br>挑战1 目的是将十六进制（hex）进行base64加密<br>所给的字符串为</p><pre><code>49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d</code></pre><p>经过base64后的输出应为</p><pre><code>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</code></pre><hr><p><strong>新手不要依赖于在线网站和工具！！！这不利于理解原理并掌握其思想，若你想做一个无脑的脚本小子，那么请继续吧！</strong></p><p>重所周知anaconda中已经集成好了很多模块，其中就包括base64，直接import就好</p><p><strong>exp1</strong></p><pre><code># -*- coding: UTF-8 -*-import base64string_hex = &apos;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&apos;# 将十六进制编码的字符进行解码string = string_hex.decode(&apos;hex&apos;)print string# 进行base64加密string_base = base64.b64encode(string)print &apos;result :&apos; + string_base</code></pre><p>具体的细节操作要自己写一遍，细细体会编程中要注意的地方，怎样更贴近人意</p><p><strong>进一步加强</strong></p><p>上述代码还是不能让我们很好的理解base64的过程，因此可以进一步扩展去了解下base64，然后自己写一个本地的base64模块。</p><p><a href="http://www.cnblogs.com/diligenceday/p/6002382.html" target="_blank" rel="noopener">base64详解</a></p><p><strong>local_base64.py</strong></p><pre><code># -*- coding: UTF-8 -*-import stringbase64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &apos;+/&apos;def encode(string):    base64_bin = [&apos;{:0&gt;8}&apos;.format(str(bin(ord(b))).replace(&apos;0b&apos;, &apos;&apos;)) for b in string]    result = &apos;&apos;    nums = len(base64_bin) // 3    remain = len(base64_bin) % 3    integral_part = base64_bin[0:3 * nums]    while integral_part:        tmp_part = &apos;&apos;.join(integral_part[0:3])        tmp_part = [int(tmp_part[x: x + 6], 2) for x in [0, 6, 12, 18]]        result += &apos;&apos;.join([base64_charset[i] for i in tmp_part])        integral_part = integral_part[3:]    if remain:        remain_part = &apos;&apos;.join(base64_bin[3 * nums:]) + (3 - remain) * &apos;0&apos; * 8        tmp_part = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]        result += &apos;&apos;.join([base64_charset[i] for i in tmp_part]) + (3 - remain) * &apos;=&apos;    return resultdef decode(string):    if not valid_base64_str(string):        return &apos;&apos;    base64_bin = [&apos;{:0&gt;6}&apos;.format(str(bin(base64_charset.index(s))).replace(&apos;0b&apos;, &apos;&apos;)) for s in string if s != &apos;=&apos;]    result = &apos;&apos;    nums = len(base64_bin) // 4    remain = len(base64_bin) % 4    integral_part = base64_bin[0:4 * nums]    while integral_part:        tmp_unit = &apos;&apos;.join(integral_part[0:4])        tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]        result += &apos;&apos;.join([chr(i) for i in tmp_unit])        integral_part = integral_part[4:]    if remain:        remain_part = &apos;&apos;.join(base64_bin[nums * 4:])        tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]        result += &apos;&apos;.join([chr(i) for i in tmp_unit])    return resultdef valid_base64_str(b_str):    if len(b_str) % 4:        return False    for m in b_str:        if m not in base64_charset + &apos;=&apos;:            return False    return Trueif __name__ == &apos;__main__&apos;:    s = &apos;ABC&apos;    s_encode = encode(s)    s_decode = decode(s_encode)    print s_encode    print    print s_decode</code></pre><p><strong>exp2</strong></p><pre><code># -*- coding: UTF-8 -*-import local_base64string_hex = &apos;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&apos;string = string_hex.decode(&apos;hex&apos;)print stringstring_base = local_base64.encode(string)print &apos;result :&apos; + string_base</code></pre><p>经过challenge1应该就能够对base64有一个很详细的了解了，还是要自己亲身尝试下才能真正掌握并转化成自己的东西。</p><h3 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h3><p><img src="https://i.imgur.com/GRIqD3Y.jpg" alt=""></p><p>挑战2 目的是让你编写一个函数，使得当你输入</p><pre><code>1c0111001f010100061a024b53535009181c</code></pre><p>让上述字符串，与下列字符串进行异或（XOR）运算</p><pre><code>686974207468652062756c6c277320657965</code></pre><p>得到的结果应该为</p><pre><code>746865206b696420646f6e277420706c6179</code></pre><hr><p>只需要进行一个异或运算，感觉起来应该不难，让我们先来了解下XOR运算操作</p><p><a href="https://blog.csdn.net/xiaopihaierletian/article/details/78162863" target="_blank" rel="noopener">逻辑运算详解</a></p><p>通过上述运算原理的介绍，可以看出这道题目就是等长度异或，实现起来很容易</p><p><strong>exp</strong></p><pre><code># -*- coding: UTF-8 -*-string_hex = &apos;1c0111001f010100061a024b53535009181c&apos;string = int(string_hex,16)string_xor = &apos;686974207468652062756c6c277320657965&apos;string_xor = int(string_xor,16)string_result = string ^ string_xorstring_result = hex(string_result)print &apos;result :&apos; + string_result[2:-1]</code></pre><h3 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge 3"></a>Challenge 3</h3><p><img src="https://i.imgur.com/hkCqCx1.jpg" alt=""></p><p>挑战3 题意是给定的下列字符串</p><pre><code>1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736</code></pre><p>是明文与某个单字符异或得到的，让我们找到密钥，并解密出明文的内容</p><p>可以手工完成，但请不要：请编写代码完成</p><hr><p>既然是编写函数，那必然要了解python中的def</p><p><a href="https://www.cnblogs.com/derezzed/articles/8119592.html" target="_blank" rel="noopener">python中的def</a></p><p>先不考虑评分标准，要先找到那个单字符<br>回想一下ascii码中一共有256个，虽然一个一个尝试对于人来说比较缓慢，但对于计算机来说应该不到一秒钟的事。所以这里决定来进行遍历尝试，也就是俗称的“暴力破解”</p><p><strong>暴力破解模块</strong></p><pre><code>def brute(string_xor):    score_pre = 0    for i in range(128):        result = &apos;&apos;        for j in re.findall(&apos;.{2}&apos;,string_xor):            k = int(j,16)            r = chr(i ^ k)            result += r</code></pre><p>这样的话，256种结果都会被存储到result中，接下来解决打分的问题，只需要对每个result进行个测评，然后比较下输出最高的就好了。</p><p><strong>exp</strong></p><pre><code># -*- coding: UTF-8 -*-import restring_xor = &apos;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&apos;def judge(s):    score_tmp = 0    freqs = {&apos;a&apos;:0.0651738,&apos;b&apos;:0.0124248,&apos;c&apos;:0.0217339,&apos;d&apos;:0.0349835,         &apos;e&apos;:0.1041442,&apos;f&apos;:0.0197881,&apos;g&apos;:0.0158610,&apos;h&apos;:0.0492888,         &apos;i&apos;:0.0558094,&apos;j&apos;:0.0009033,&apos;k&apos;:0.0050529,&apos;l&apos;:0.0331490,         &apos;m&apos;:0.0202124,&apos;n&apos;:0.0564513,&apos;o&apos;:0.0596302,&apos;p&apos;:0.0137645,         &apos;q&apos;:0.0008606,&apos;r&apos;:0.0497563,&apos;s&apos;:0.0515760,&apos;t&apos;:0.0729357,         &apos;u&apos;:0.0225134,&apos;v&apos;:0.0082903,&apos;w&apos;:0.0171272,&apos;x&apos;:0.0013692,         &apos;y&apos;:0.0145984,&apos;z&apos;:0.0007836,&apos; &apos;:0.1918182         }    for x in s.lower():        if x in freqs:            score_tmp += freqs[x]    return score_tmpdef brute(string_xor):    score_pre = 0    for i in range(128):        result = &apos;&apos;        for j in re.findall(&apos;.{2}&apos;,string_xor):            k = int(j,16)            r = chr(i ^ k)            result += r        score = judge(result)        if score &gt; score_pre:            score_pre = score            final = result            key = chr(i)    return final,keyfinal,key = brute(string_xor)print finalprintprint key</code></pre><p>这里是字母采用频率的方法进行测评，python3中带有wordfreq模块直接可以查取字符频率，无奈使用的是python2，只能采用其他人收集的频率情况。</p><h2 id="南宁市网络安全技术大赛（Crypto）"><a href="#南宁市网络安全技术大赛（Crypto）" class="headerlink" title="南宁市网络安全技术大赛（Crypto）"></a>南宁市网络安全技术大赛（Crypto）</h2><p>writeup分享者：Mengmeng</p><h3 id="维吉尼亚遇上困难"><a href="#维吉尼亚遇上困难" class="headerlink" title="维吉尼亚遇上困难"></a>维吉尼亚遇上困难</h3><p>密文：<br>BZGTNPMMCGZFPUWJCUIGRWXPFNLHZCKOAPGLKYJNRAQFIUYRAVGNPANUMDQOAHMWTGJDXGOMPJPTKAAVZIUIWKVTUCWBWNFWDFUMPJWPMQGPTNWXTSDPLPMWJAXUHHXWPFXXGVAPFNTXVFKOYIRBOQJHCBVWVFYCGQFGUSUBDWVIYATJGTBNDKGHCTMTWIUEFJITVUGJHHIMUVJICUWYQWYGGUWPUUCWIFGWUANILKPHDKOSPJTTWJQOJHXLBJAPZHVQWPDYPGLLGDBCHTGIZCCMEGVIIJLIFFBHSMEGUJHRXBOQUBDNASPEUCWNGWSNWXTSDPLPMWJAIUHUMWPSYCTUWFBMIAMKVBNTDMQNBVDKILQSSDYVWVXIGDQFIBHSLEAVDBXGOLGDBCHTGIZVNFQFKTNGRWXUDCTGKWCOXIXKZPPFDZGXNBAXLGGWBLTLWCKOXAR</p><p>题目已经给出很明显的提示了，是维吉尼亚密码，根据密文的长度，可以确定是想让我们进行无密钥破解维吉尼亚密码，原理如下：</p><p><a href="https://blog.csdn.net/limisky/article/details/16885959" target="_blank" rel="noopener">维吉尼亚密码及其破解原理</a></p><p>用github上的工具，跑一下,得到flag<br><img src="https://i.imgur.com/QMFAvbz.png" alt=""></p><p><a href="https://atomcated.github.io/Vigenere/" target="_blank" rel="noopener">维吉尼亚无密钥破解工具</a></p><p>该工具可以直接下载下来，部署到本地</p><p>flag:{YOU ARE SO KINDLY}</p><h3 id="shamir重要数据损坏"><a href="#shamir重要数据损坏" class="headerlink" title="shamir重要数据损坏"></a>shamir重要数据损坏</h3><p>该题目考查的是Shamir秘密共享算法</p><p> <img src="https://i.imgur.com/KyHYt6N.png" alt=""></p><p> 大概了解了之后用题目给的信息进行计算<br> <img src="https://i.imgur.com/INN4jMu.png" alt=""></p><p> X1=5，X2=7，X3=9</p><p>（X_1,f(X_1)）=(5,2258)</p><p>（X_2,f(X_2)）=(7,2424)</p><p>（X_3,f(X_3)）=(9,2630)</p><hr><p>a0+a_1 x_1+a_2 x_1^2=2258</p><p>a0+a_1 x_2+a_2 x_2^2=2424</p><p>a0+a_1 x_3+a_2 x_3^2=2630</p><p>代入x1,x2,x3,经计算可得a0=2018，a1=23,a2=5<br>所以s=a0=2018<br>flag：{2018}</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>对于小白来讲，可能会觉得这些东西有点晦涩。但我想说的是，这仅仅只是个入门，至今为止我都坚信一万个小时定律，这段时间的锤炼是让你从平凡变成大师的过程，若是能踏踏实实走完，想必你不会后悔，我会伴随你们一同前行，加油我们的信安之路！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello my New World</title>
      <link href="/2018/12/20/Hello-my-New-World/"/>
      <url>/2018/12/20/Hello-my-New-World/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天给萌萌尝试着搭建了这个博客，花了差不多半天的时间，部分功能还没调试完成，总的来说界面很清新，我倒是蛮喜欢的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这次更新了之后，就应该不会再进行大的变动了，也是时隔一段时间没有更新博客了。<br>原因是前一段时间满课，周末在忙着比赛，基本上是天天加班，顺着带着也记录下这段时间的经历吧</p><p>“领航杯”之后应该一直都是满课的，从早上到晚。对于课程的安排我反正是无力吐槽了，身为一名大四的信安专业学生，却在课堂上一点专业知识都学不到。</p><p>“东华杯”的线上赛发挥还是挺好的，拿下了一道密码二血，跟着蒋师傅把战队总到了决赛，可惜决赛那周周末比赛较多，少了一次线下比赛的机会。转身去打了X-nuca全国高校联赛。</p><p>X-nuca是在厦门打的，是作为“博鹭杯”同行去厦门的，虽说是同行不用上场，但X-nuca的线上同样至关重要，只有我和蒋师傅两个人参加，可以说线上打得是十分难受了，从头至尾我这个密码+三流web手只解出了一道题目，最后还是靠着徐教员的帮忙，才挺进了决赛。还是自己太菜了。。</p><p>“鹏城杯”的线上赛还是蛮轻松的，密码题拿了个一血，misc和web也是在何师傅的指导下出了几道题目，最后凭着一个不错的名次进入了决赛</p><p>X-nuca和“鹏城杯”的线下赛是我今年成长最大的一次。也正是这两场比赛真正地打醒了我这只菜鸡。。满场纷飞的pwn题打得我没脾气。由于主办方的失误有幸让我们提前拿到了源码，虽说分析了一波写出了exp，但在服务器上线的时候，瞬间就被打到绝望。</p><p>赛后打听到，牛*的大佬队伍都是本地跑好了连接ssh，down源码的脚本，就算单身二十年的手速同样是追不上计算机的脚步啊。。。跟神仙们的差距太大了，不论是思路还是技术都很落后，现在早已不是闭关修炼二十年出山就能当老大的时代了。</p><p>本事是自己的，我不甘心做一只井底之蛙。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
