<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>网络攻防实践_day1</title>
      <link href="/2019/04/01/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E8%B7%B5_day1/"/>
      <url>/2019/04/01/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E5%AE%9E%E8%B7%B5_day1/</url>
      
        <content type="html"><![CDATA[<h1 id="网络攻防实践-端口扫描"><a href="#网络攻防实践-端口扫描" class="headerlink" title="网络攻防实践_端口扫描"></a>网络攻防实践_端口扫描</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>端口扫描是渗透测试中的重要一环。所谓的端口扫描，就是指通过TCP握手或者别的方式来判别一个给定主机上的某些端口是否处理开放，或者说监听的状态。现有的使用比较广泛的端口扫描工具是nmap。毋庸置疑，nmap是一款非常强大且易于使用的软件。但nmap是一款运行于terminal中的软件，有时在别的代码中调用并不是很方便，甚至没有相应的库。另外，nmap依赖的其他库较多，在较老的系统中可能无法使用较新的nmap，这样会造成扫描的不便。另外，nmap在扫描时需要root权限。基于这个原因，我用python2.7自带的库开发了一款高效的多线程端口扫描器来满足使用需要。</p><h2 id="任务目标"><a href="#任务目标" class="headerlink" title="任务目标"></a>任务目标</h2><pre><code>   1、实现指定端口扫描2、线程加速3、获取banner信息4、通过主机与端口信息对比漏洞数据库</code></pre><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><h3 id="一、实现指定端口扫描"><a href="#一、实现指定端口扫描" class="headerlink" title="一、实现指定端口扫描"></a>一、实现指定端口扫描</h3><p>为了实现端口扫描，我们首先明白如何使用python socket与给定的(ip, port)进行TCP握手。为了完成TCP握手，我们需要先初始化一个TCP socket。在python中新建一个TCP socket的代码如下：</p><p><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_16-49-12.jpg" alt=""></p><p>其中</p><p>(1)是初始化socket的代码，socket.AF_INTE参数表示IPv4 socket，socket.SOCK_STREAM参数表示TCP socket。这样我们就初始化了一个使用IPv4，TCP协议的socket。</p><p>(2)使用了socket.setsockopt()来设置socket的另一些参数。socket.SOL_SOCKET指定当前socket将使用setsockopt()中后面的参数。socket.SO_REUSEPORT表明当前socket使用了可复用端口的设置。socket.SO_REUSEPORT具体含义可以参考我的另一篇文章。</p><p>(3)将socket的连接超时时间设置为delay变量所对应的时间（以秒为单位）。这么做是为了防止我们在一个连接上等待太久。<br>了解了如何新建一个socket，我们就可以开始对给定的(ip,port)对进行TCP连接。代码如下：</p><p><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_16-44-48.jpg" alt=""></p><h3 id="二、实现多线程扫描"><a href="#二、实现多线程扫描" class="headerlink" title="二、实现多线程扫描"></a>二、实现多线程扫描</h3><p>必然是要通过线程来加速扫描过程，但考虑到全端口的大面积扫描，单线程就显得过于鸡肋了。所以，这里直接选择多线程进行扫描。设计思路也很简单，就是为每一个端口单独开设一个线程来进行扫描。我也是查找了一些常用的端口号<br><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_16-55-38.jpg" alt=""></p><p>对于一个给定的ip地址，扫描的过程是这样的：</p><pre><code>1. 取出一个端口2. 新建一条线程，利用__TCP_connect()函数对该(ip,port)进行连接操作。3. 调用thread.start()方法，使扫描的子线程开始工作并且命令主线程等待子线程死亡后再结束。4. 重复这个过程直到所有的端口都被扫描过。</code></pre><p>根据上面的思路，代码如下：</p><p><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_17-03-07.jpg" alt=""></p><h3 id="三、获取banner信息"><a href="#三、获取banner信息" class="headerlink" title="三、获取banner信息"></a>三、获取banner信息</h3><p>获取banner的方法比较简单，只需要在建立连接后插入一段代码即可，如下：<br><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_17-13-03.jpg" alt=""></p><h3 id="四、调用漏洞库的对比情况"><a href="#四、调用漏洞库的对比情况" class="headerlink" title="四、调用漏洞库的对比情况"></a>四、调用漏洞库的对比情况</h3><p>大概查了下资料，这里需要根据扫出来的端口信息，去调用metasploit漏洞库，也就是通过python终端去执行os.system()命令，具体实现没有多大意义，这里不再添加该功能</p><h2 id="实践效果"><a href="#实践效果" class="headerlink" title="实践效果"></a>实践效果</h2><p>我自己在实验室找了台主机来做测试，一方面使用我自己的扫描器，另一方面使用Nmap的 -sT 来进行扫描，对比结果来查看实际效果。</p><p>Nmap扫描结果1<br><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_17-19-23.jpg" alt=""></p><p>我的扫描器结果1<br><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_17-22-55.jpg" alt=""></p><p>Nmap扫描结果2<br><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_17-23-59.jpg" alt=""></p><p>我的扫描器结果2<br><img src="/Users/ahai/Documents/网络攻防实践/Xnip2019-04-01_17-25-13.jpg" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的结果来看，在banner的获取与扫描速度方面，我的稍稍占优。但在端口判断的准确率上我的会有所不足，当扫描的端口数量过多时，就会出现漏报现象，并且我的扫描器只能针对单台主机，并不能实现网段扫描，这也是一大弊端</p>]]></content>
      
      
      
        <tags>
            
            <tag> Nmap </tag>
            
            <tag> 端口扫描 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Wi-Fi基本知识学习</title>
      <link href="/2019/01/05/Wi-Fi%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/01/05/Wi-Fi%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概述"><a href="#基本概述" class="headerlink" title="基本概述"></a>基本概述</h1><h2 id="有线和无线网络"><a href="#有线和无线网络" class="headerlink" title="有线和无线网络"></a>有线和无线网络</h2><p>目前，有线网络中最著名的是以太网（Ethenet），但是无线网络WLAN是一个很有前景的发展领域，虽然不会完全取代以太网，但是随着便携式的发展，它会拥有越来越多的用户，无线网络中最有前景的就是Wi-Fi技术。</p><p>无线网络相比有线网络，还是有很多不足的</p><ol><li>通信双方因为是通过无线进行通信，所以通信前需要建立连接；而有线网络就直接使用线缆连接，就不需要这个过程了。</li><li>通信双方通信方式是半双工的通信方式；而有线网络可以全双工</li><li>通信时在网络层一下出错的概率非常高，所以帧的重传概率很大，需要在网络层之下的协议添加重传机制（不能只依赖于上层TCP/IP的延时等待重传等来保证）；而有线网络出错概率非常小，无需在网络层有如此复杂的机制。</li><li>数据是在无线环境下进行的，所以抓包很容易，存在安全隐患</li><li>因为收发无线信号，所以功耗很大，对电池要求较大</li><li>相对有线网络吞吐量低，这一点正在逐步改善，802.11n协议可达600Mbps的吞吐量。</li></ol><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Ethenet和Wi-Fi采用的协议都属于IEEE802协议集。其中，Ethenet以802.3协议做为其网络层以下的协议；而Wi-Fi以802.11做为其网络层以下的协议。无论是有线网络，还是无线网络，其网络层以上的部分，基本一样。</p><p>这里主要关注下Wi-Fi网络中相关的问题。Wi-Fi的802.11协议包含许多子部分。其中按照时间顺序发展，主要有：</p><ol><li>802.11a，1999年9月制定，工作在5GHz的频率范围（频段宽度325MHz），最大传输速率54mbps。</li><li>802.11b，1999年9月制定，时间比802.11a稍晚，工作在2.4G的频率范围（频段宽度83.5MHz），最大传输速率11mbps。</li><li>802.11g，2003年6月制定，工作在2.4GHz频率范围（频段宽度83.5MHz），最大传输速率54mbps。</li><li>802.11n，2009年发布，在2.4GHz和5GHz均可工作，最大传输速率为600mbps</li></ol><p>这些协议均为无线网络的通信所需的基本协议，最新发展的，一般要比最初的有所改进。</p><p>另外值得注意的是，802.11n在MAC层进行了一些重要的改进，所以导致网络性能有了很大的提升，比如：</p><ol><li><p>因为传输速率很大程度上取决于Channel（信道）的ChannelWidth有多宽，而802.11n协议中采用了一种新技术，可以在传输数据时，将两个信道合并为一个进行传输，这样极大地提高了传输速率（又称HT-40，high through）</p></li><li><p>802.11n的MIMO（多输入输出）特性，使得两对天线可以在同时同Channel上进行传输数据，而两者却能够不互相干扰（采用了OFDM特殊的调制技术）</p></li></ol><p>以上更新于2018年1月5日….</p><hr><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>讲述之前，我们需要对无线网络中一些常用的术语有所了解。这里先列出一些，后面描述中出现的新的术语，将会在描述中解释。</p><ol><li>LAN：即局域网，是路由和主机组成的内部局域网，一般为有线网络</li><li>WAN：即广域网，是外部一个更大的局域网</li><li>WLAN（Wireless LAN，即无线局域网）：前面我们说的LAN是局域网，更多指的的是有线网络中的局域网，无线网络中的局域网，一般用WLAN</li><li>AP（Access Point的简称，即访问点，接入点）：是一个无线网络中的其他类型节点，可以和无线网络外部以及内部进行通信。一般AP和无线路由都在一台设备上。</li><li>Station（工作站）：表示连接到无线网络中的设备，这些设备通过AP，可以和内部其他设备或无线网络外部通信。</li><li>Associate（连接）：如果一个Station想要加入到无线网络中，需要和这个无线网络中的AP关联（即Associate）</li><li>SSID：用来标识一个无线网络，后面会详细介绍，我们这里只需了解，每个无线网络都有它自己的SSID。</li><li>BSS（Basic Service Set）：由一组相互通信的工作站组成，是802.11无线网络的基本组件。主要有两种类型：IBSS和基础结构型网络。IBSS又叫ADHOC，组网是临时的，通信方式为Station<->Station；基础结构型网络，其通信方式是Station<->AP<->Station，也就是所有无线网络中的设备想要通信，都要经过AP。在无线网络的基础型网络中嘛，最重要的两种设备：AP和Station。</-></-></-></li><li>BSSID：用来标识一个BSS，其格式和MAC地址一样，是48位的地址格式。一般来说，它就是所处的无线接入点的MAC地址。某种程度来说，他的作用和SSID类似，但是SSID是网络的名字，是给人看的。BSSID是给机器看的，BSSID类似MAC地址。</li><li>DS（Distributed System）：即分布式系统。分布式系统属于802.11逻辑组件，负责将帧转发至目的地址，802.11并未规定其技术细节，大多数商业产品以桥接引擎和分布式系统媒介共同构成分布式系统。分布式系统是接入点之间转发帧的骨干网络，一般是以太网。其实，骨干网络并不是分布系统的全部，而是其媒介。主要有三点：骨干网（例如以太网）、桥接器（具有有线无线两个网络接口的接入点）、属于骨干网上的接入点所管辖的基础型网络的station通信（和外界或者BSS内部的station）</li></ol><p>以上更新于1月6日….</p><h1 id="实践基础"><a href="#实践基础" class="headerlink" title="实践基础"></a>实践基础</h1><h2 id="一些参数"><a href="#一些参数" class="headerlink" title="一些参数"></a>一些参数</h2><ol><li>MAC：MAC（即Media Access Control，介质访问控制），是数据链路层的一部分。MAC地址是烧录在NetworkInterfaceCard（即网卡，NIC）里的，他也叫硬件地址，是由48位（即bit，一字节为8位，即1byte=8bits）16进制的数字组成。其中0-23位叫做组织唯一标志符（Orgnizationnally unique，简称OUI），是识别LAN（局域网）节点的标识（在有些抓包工具抓包的时候会将前三个字节映射成某种组织名称的自负，也可以选择不显示这种映射），24-47位是由厂家自己进行分配。</li><li><p>SSID：表示一个子网的名字，无线路由通过这个名字可以为其他设备标识这个无线路由的子网。设备进行扫描的时候，就会将相应的SSID扫描到，然后就能够选择相应的SSID连接到相应的无线网络（当然不扫描，理论上也可以直接指定自己事先已经知道的SSID进行连接）。SSID允许存在重复，这样在扫描的时候会看到两个同样的SSID无线网络，其实这一般用于将一个无线网络扩大的情况（毕竟无线路由器无线信号的覆盖范围是有限的）：当想要扩大一个无线网络（即SSID固定）的范围的时候，可以给多个路由设置相同的SSID来达到这个目的。（这也是漫游的原理，漫游的时候，我们可以在远方或者本地都能打电话，也就是访问移动通信网络）。</p><p> SSID和BSSID不一定一一对应，一个BSSID在不同的Channel上面可能会对应多个SSID，但是他们在一个Channel上是一一对应的；另外，漫游的时候，虽然SSID不变，但是BSSID一定是会变化的。我们经常可以看到实际数据包中AP的MAC地址和BSSID只差几位，其实实际设备的MAC地址可能只有一个，和BSSID没什么对应关系。在一个包含了路由功能和AP功能的无线路由器（Fat AP）上面，很可能是：路由器有两个MAC地址，一个用于外网（WAN），一个用于内网（WLAN和LAN），一般路由器上面或者或者配置路由器的网页上面只标注外网的MAC地址；内网的MAC地址和外网MAC地址一般只有几位不同（甚至连续，也有些相差很多的例外）。</p></li><li>Band（频率范围）：一般AP可以支持5G或2.4G两个频率范围段的无线信号。如果两者同时可以设置，而不是互斥，那么这个路由器还能够同时支持两种频段（频段即为Band），这相当于这个AP可以建立两个无线网络，他们采用不同的频段（这类似收音机在长波范围内收音和短波范围内收音）。</li><li>Channel（信道）：Channel是对频段的进一步划分（将5G或者2.4G的频段范围再划分为几个小的频段，每个频段称作一个Channel）。处于不同传输信道上面的数据，如果信道覆盖范围没有重叠，那么不会相互干扰。对于信道的使用，在国际上有所规定。其中有些信道是无需授权即可使用的（究竟是哪个频段的信道，依照各个国家而不同），无需授权使用的意思是，传输数据的时候（无论以哪种无线方式），可以让设备收发的功率导致传输时的数据进入该信道的频率并在该信道所在频段宽度内进行传输；授权使用的意思是，不允许使用授权信道进行传输，否则会违反规定，并且干扰信道上其他数据的传输。另外，除了Wi-Fi，微波、红外线、蓝牙（使用802.15协议）的工作频段也都有在2.4GHz范围内的，所以他们传输的时候会对Wi-Fi传输造成干扰，因为两者在不同的协议下进行通信，所以互相将对方传输的信号识别为噪声。有时候配置AP的时候，Channel中有一个类似“Auto”的选项值，这表示打开AP的时候，AP自己Scan周围的环境，选择一个干扰最小的Channel来进行通信，当选择好了一个Channel的时候，一般就不会改变了。</li><li><p>Channel Width（信道宽度）：这里的Channel Width是信道的带宽，有“20MHz”、“40MHz”等，它表示一个Channel片段的宽度（假设5G的频段宽度总共为100M，平均划分为互不干扰的10个Channel，那么每个Channel的Channel Width就为100M/10=10M，实际Channel并不一定是不重叠的）。这个参数可能依赖于一些其他的选项，例如不是802.11协议，就不可能会有40MHz的Channel Width（N模式有一个特点就是可以把两个Channel合并，通过提高Channel Width来提高吞吐量）。例如选择了“20MHz”这个Channel Width之后，后面再选择一个“5.18GHz”的Channel，则表示以5.18GHz为中心的前“10MHz”以及其后面的“10MHz”频带范围被占用。</p><p> 至此可知，配置无线AP的时候，如果屋子里面有很多AP（也就是无线路由器接入点）的话，仔细设置他们的Channel Width和Channel可以保证他们相互之间的干扰（类似收音机里面的串台）尽可能小。当然，如果互相干扰了，那么Net Mode所指定的协议也会有相应的处理方式让他们之间进行协调（例如让谁先通信谁等一会儿再通信之类的），但是这样网络的性能就不如没有干扰的时候好了。</p></li><li>Wireless Security（无线网络的安全性）：这里主要涉及WEP、WPA、WPA2和RC4、TKIP、AES。<br> IEEE 802.11所制定的是技术性标准，Wi-Fi联盟所制定的是商业化标准，而Wi-Fi所制定的商业化标准基本上也都符合IEEE所制定的技术性标准。WEP是1999年9月通过的IEEE802.11标准的一部分；WPA(Wi-Fi Protected Access）事实上就是由Wi-Fi联盟所制定的安全性标准；而WPA2其实就是WPA的第二个版本。直观点说，WEP是较老的认证方法，它有好几个弱点，因此在2003年被WPA淘汰，WPA又在2004年由完整的IEEE802.11i标准（又称为WPA2）所取代。<br> WEP（Wired Equivalent Privacy），采用名为RC4的RSA加密技术；WPA（Wi-Fi Protected Access），采用新的TKIP算法，TKIP算法保留了RC4，所以也有其弱点，但是这个时候更好的CCMP还没完成，所以现在WPA上用TKIP技术；WPA2是WPA的第2个版本，采用CCMP加密协定（在有些路由器等设备上设定加密协定或者加密算法的时候，可能会用类似AES之类的字眼替代CCMP）。所以WPA2+AES是安全性最强的。<br> 另外，在有些无线网络设备的参数中会看到像WPA-Enterprise/WPA-Enterprise就是WPA/WPA2；WPA-Personal/WPA2-Personal其实就是WPA-PSK/WPA2-PSK，也就是以“pre-share key”或“passphrase”的验证（authentication）模式来代替IEEE802.1X/EAP的验证模式，PSK模式下必须使用验证服务器（例如RADIUS Server），所以特别适合家用或者SOHO的使用者。<br> 还有，wep是旧的加密方式，工作于802.11b/g模式下，而802.11n草案并不支持此加密方式，所以如果802.11n的设备采用wep加密方式后，他也只会工作在802.11b/g模式下，n的性能发挥不出来。<br> 实际中，在有些路由上面，设置的时候，可能不是严格按照这个规定来设置的（例如设定了采用WPA方式，还可以选择AES），但大体上如此。</li><li>Region（区域）：一般在无线网络中的AP上都有一个参数，表明它是处于哪个Region（地区）。Station根据AP中设置的Region调整其相应的发射功率以遵守该地区的规定。AP调整过程一般都是手动设定，设置好AP所处的Region之后，这些信息就会在AP发送的Beacon帧（后面会说到）中包含了；通过这个AP连接到无线网络上的Station，从Beacon帧中了解到这些Region信息，并且根据这些信息中的规定和AP进行通信。如果AP开始设置错了，那么Station和AP通信的时候，采用的将是不符合Region规定的频段，可能会对该Region中的其他传输网络造成干扰，这应当是“非法”的。</li><li><p>Transmission Rate（传输速率）：设置传输速率。这里采用不同的无线网络传输协议（802.11a，802.11b，802.11g等），那么可以设置的速率范围有所不同，这里的速度是指理论的速度。实际中，由于各种干扰因素，传输的速率可能会比设置的小。</p><p> 一般而言，在无线网络中，对于某种协议的性能进行描述时，我们需要注意的是，描述时提到的传输速率（Datarate）和吞吐量（Throughput）是不同的。Datarate是理论上面的最大数据传输速率，而Throughput是数据的实际最大吞吐量。因为厂家以及传输时所使用的协议等各种因素造成的开销，会导致实际吞吐量比理论吞吐量要小，一般实际最大吞吐量为理论最大的50%左右（一个不太准确但是相对直观的估计：在网络中，高清视频所需的Throughput也就30mbps左右，网络上一般的视频也就4mbps左右）</p><p> 以上更新于2019.1.16….</p></li><li><p>Qos（质量保证）：无线网络中的QOS是质量保证，大致的意思是，传输数据的时候，考虑各种因素（例如收费策略，所处地区等），以一定的优先级来保证传输的特定要求（一般就是速度），如果带宽足够的话，QOS反而不需要了。</p></li><li><p>RTS Threshold/CTS Protection Mode：这里的RTS是Request-To-Send的简写，CTS是Clear-To-Send的简写。设置好RTS的阈值后，如果超过这个阈值就会在发送信息之前发送RTS，以减少干扰，相应的CTS会回应之前的RTS。一般都是AP发送CTS数据，而Station发送RTS数据。</p><p>这里对RTS和CTS做一个简单的解释：假设在同一个AP所覆盖的无线网络范围内的两个Station A和B，它们之间可能会因为距离的原因互相不可见（例如它们在AP网络范围的两端，而这两端的距离大于两者的信号覆盖范围），但是AP却知道它们是在自己的范围内，当一个A想要在AP网络中进行通信的时候，必定要经过AP转发它的信息，由于A不知道B的存在，所以如果同时B也通过AP进行网络通信，那么会出现AP同时收到A、B两个Station的通信请求，而在这无线网络中是不允许的（无线网络中，同一时刻不能有多个人传输数据）。在这种情况下，B和A相互干扰了对方的通信，但是却互相不可见（不可见的节点互相被称作隐藏节点）。如果在一个网络中，这样的节点很多，那么势必会影响网络的性能（因为一旦数据发送失败，就要重传，隐藏节点会导致重传的几率增大）。这个时候，可采用RTS和CTS机制。即：在A想要通信的时候，先广播发送RTS给AP，告诉AP“它想要通信”，同时接受到RTS的别的Station（它们对发送RTS的Station言而可见）会知道A将要发送数据，于是它们不会发送数据以免干扰A：AP收到RTS之后，会广播发送CTS，告诉所有在AP范围内的Station（包括对A而言的隐藏节点B）“A将要通信（同时也相当于告诉A，A可以无干扰的发送信息了）”，这样对A而言的隐藏节点B也知道有一个A的存在并且要发送信息了，于是B就不会干扰A了。这里，A和B两者可以在不同的网络上，也就是说，不同网络的工作站之间也可以通过RTS/CTS来清除相互的干扰。</p></li><li>Beacon Interval：表示无线路由定期广播其SSID的时间间隔，这个一般不会特别设置，就采用默认值即可。如果不广播了，那么Station端扫描的时候可能会发现不定期广播的AP对应的SSID的网络不见了，所以可能会断开连接。这里定期广播，表示AP会定时向其范围内广播SSID的信息，以表示AP的存在，这样Station进入一个区域之后，就能够通过扫描知道这个区域是否有AP的存在。当然，除了AP广播SSID以告知其无限网络存在之外，Station也可以主动广播探寻包，在其能够覆盖的范围内询问是否有AP存在（即我们通常所说的扫描寻找接入点）。</li><li>DTIM Interval：DTIM/TIM表示告诉Station，AP在为Station做package buffer（例如Station睡眠的时候）的缓存时间。为了节省电池使用时间，处于无线网络中的Station可能会在一定时间之后自动进入休眠状态。这个时候，AP会为这个Station缓存发送给它的数据，而处于休眠状态的Station只会在一定的时间间隔内给AP发送一个数据帧，以确认是否有发送给自己的数据存在。例如，当我们在主机上ping另外一台睡眠的机器的时候，收到另外一台机器响应的时间，要比它不休眠的时候响应的时间长的多。</li><li><p>Fragmentation Threshold：表示一个package的分片阈值，我们可以设置分片大小，当发送的数据包超过这个阈值后，802.11协议会自动对这个数据包进行分割。如果设置的这个分片值越小，那么整个数据包越容易传输成功（因为如果出错，那么只需要传送一个片段而不是整个包，无线Wi-Fi网络中数据传输时出错的概率比有线的以太网要大得多的多），当然开销也就越大（因为需要额外的信息标记每个分片，以及各个分片传输成功之后涉及到的重组问题）。</p><p>以上更新于2019.1.17….</p></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p>一般来说，我们机器上的软件抓取无线网卡上面的数据包的时候，其实这些包的目的地址都是这台机器的无线网卡，因为不是发给这个机器无线网卡的包都被网卡过滤了。所以我们想要抓取所处无线网络环境下所有的包的时候，需要给机器配备一种特殊的设备（sniffer就是嗅探器），然后再通过抓包工具抓取并分析。有一个硬件设备叫做AirPcap，就是做这个用的，大有几百到上千美金，他可以同时作为嗅探器或者无线网卡使用，不过作为嗅探器的时候，会抓取所有经过它的包。这个工具目前只有windows上面的驱动，所以使用这个工具，只能在Windows上面，配合Wireshark抓包软件进行抓包。</p><p>这里假设采用AirPcap嗅探，Wireshark软件抓包（其他抓包软件，例如Linux下面的tcpdump等分析类似）。不用图形方式详细展示具体的抓包过程以及分析方法了，主要说一下抓包（这里的包实际主要指的是网络层以下的包，更常见的称呼应该是数据帧）时应该注意的问题。</p><ol><li>Wireshark展示包的时候，大致都是按照协议规定的字段展示，有些地方按照它自己特定的方式展示。因为这里着重讲述一些抓包时注意的基本原理上面的东西，所以不会对此进行过多阐述。大致就是：Wireshark软件中，对包展示的时候，按照协议规定的字段分别用Header和Body两个部分展示；另外，在Header之前还有两个部分是Wireshark为方便用户而展示的包的大小、时间等全局信息（例如见过表示这个包在b和g模式中的Channel 1时，用“BG1”表示）。所以，其实我们分析的时候，实际应该按照后面的Header和Body两个部分进行。后面讲基于以上所述，进行进一步讲解。</li><li>抓包的时候，需要首先确认这个包是否是完整、正确的包。只要是校验位（checksum）不对的，就是错误的包，也无法确定接收的时候哪里出了差错，所以这个包应该是忽略的，几乎没有分析的价值。另外，抓包的时候，由于干扰等原因，抓取的内容可能不是在实际传输所处的Channel上的包（例如在Channel1上嗅探，却嗅探到了Channel2的包）。</li><li>抓取授权阶段的包，需要注意实际的授权是在后面进行的。Authentication的时候，开始阶段实际是Open的（即开放无授权），也就是说，开始实际已经建立好了连接，所以我们在抓包的时候，开始看到的一般都是通过验证，但是后面紧接着就采用了类似802.11x等安全加强的协议，来进行再次加强认证，如果这里无法通过则立即将已经建立的Association断开。这样的机制，是因为原来的802.11没有充分考虑安全才会这样的，这样也兼容了以前的802.11。</li><li>抓取的包的数据，要注意这个包是否是被加密过的，根据协议标准的描述，包中如果有dataprotected字段，则表示这个数据本身是被加了密的，不知道这个数据具体是什么，当然，如果有密码，Wireshark也有一个可以按照这个密码解密的工具，有时候不好用。这里所说的数据加密和网络的加密不一样，可能访问网络本身是需要密码的（网络是security的），而数据本身没有encrypted（加密）。对于一个加了密的数据包，我们一般看不出来这个包到底是做什么用的或者什么类型的等等。</li><li>抓包的时候，要注意包中指示的源地址和目的地址以及包的序列号。在无线网络中通信的时候，我们抓包的时候可能会看到被抓去的包对应AP的MAC地址是不存在的，其实抓包时AP的MAC是BSSID，它和实际标注的MAC地址不一定一样（但是一般都差不多，也就是之后最后面的几位不一样）。有时候，我们看到抓取的包中的MAC地址有许多只相差几位，那么可能它们都属于一个设备（因为虽然设备可能只标注了一个网卡的MAC地址，但是它却“虚拟”出或者实际有多个MAC地址），所以当我们看到包中对应两个AP的MAC地址几乎一样的时候，一般来说，这两个MAC地址很可能就是一个设备的。还有在抓包的时候，一个地址上面的包的sequence（序号）是连续的，除非丢包了导致重复或者确缺失。如果一个设备虚拟出来两个地址，那么也可能由于没有经过什么处理，导致这两个地址上面的包共同起来是连续的（如前所述，这两个地址和MAC很接近，应该是BSSID）。</li><li>抓取的数据帧如果是广播帧则不需要确认（ACK），如果是单播帧，则一般需要确认（ACK）。例如，Probe帧是广播帧，所以它无对应的ACK确认帧，对Probe的回复则叫做Probe Response；注意ACK帧本身用于确认，是单播的，但是它本身却不需要再被确认了。从包中的目的MAC地址中，可以看出这个包是广播/多播帧还是单播帧，MAC第一个字节的第一位是1，表示组播，前两位是1表示广播，第一个字节第一个位是0表示单播。这里注意，MAC不是值，而是一个Pattern，所以没有Endian之说，也没有哪个位高，哪个MAC大之说。例如：“a8:27:26:…:b7”，这里第一个字节就是a8（10101000），其第一个字节的第一位就是8的最“右”位，即“0”，所以它的第一个字节的第一个位是0，是一个单播地址。其实，这里涉及到大端小端的问题，后面也会讲到，总之，以太网线路上按“Big Endian”字节序传送报文（也就是最高字节先传送），而比特序是“Little Endian”（也就是字节内最低位先传送）所以，一个十六进制表示法表示的MAC地址01-80-C2-00-00-00，传送时的bit顺序就是：1000 0000 0000 0001 0100 0011 0000 0000 0000 0000 0000 0000。</li><li>使用Wireshark在抓包或者显示包的时候，都可以设置过滤器（filter）。抓包时候设置的过滤器叫capture filter，它是用BPF（berkerley package filter）这个比较通用的语言来描述（注意这不是Wireshark专用的filter语言，而是一个通用的语言），但是抓包期间的过滤，有时候不准，所以我们一般先将所有的包抓取下来，然后用Wireshark中显示的过滤器（即View filter）来显示我们关注的包，这里我们可以用macro来定义比较复杂的显示过来条件。保存的时候，可以用按照显示过滤还是抓取过滤的方式保存内容</li><li>尽量不要抓取Channel Width为40MHz的Channel上的帧。我们还需要注意的是，使用Sniffer抓取无线网络包的时候，AirPcap无法正常抓取40MHz Channel Width的包，或者说对抓取这个Channel Width上面的包支持不好。如果非要抓取40MHz Channel Width的包，那么就在40或者36号Channel上面进行抓取，并在Wireshark上面设置“Channel=36，offset+1”（平时offset=0），这样能够抓取Channel Width为40MHz的包（但是，其他Channel上面的40MHz的包还是无法抓取），这是由AirPcap内部的芯片固件的问题决定的（估计broad com芯片公司也不愿意花过多的精力来支持这个很少有人用的抓包工具的这个功能）</li></ol><p>另外，假设一个无线工作站是基于Android系统的（例如平板电脑或者智能手机和电子书）那么我们可以利用“wpa_cli status”命令来可以查看当前设备连接的SSID、BSSID、MAC、IP等信息，（这里“cli”=“command line interface”)。还有更“复杂”的命令“wc”和“wl”，其中wc是比较上层的命令，wl是下层的命令（是基于芯片是否支持的，例如wl在Broadcom芯片上支持，但是在ti上面就没有了）。</p><h1 id="一些原理"><a href="#一些原理" class="headerlink" title="一些原理"></a>一些原理</h1><h2 id="常见的帧"><a href="#常见的帧" class="headerlink" title="常见的帧"></a>常见的帧</h2><p>在802.11中的帧有三种类型：管理帧（Management Frame，例如Beacon帧，Association帧）、控制帧（Control Frame，例如RTS帧，CTS帧、ACK帧）、数据帧（Data Frame，承载数据的载体，其中的DS字段用来标识方向很重要）。帧头部中的类型字段中会标识出该帧属于哪个字段。</p><ol><li>Beacon帧：Beacon帧定时广播发送，主要用来通知网络AP的存在性。Station和AP建立Association的时候，也需要用到Beacon。Station可以通过Scan来扫描到Beacon，从而得知AP的存在，也可以在扫描的时候主动发送Probe来探寻AP是否存在。也就是说，建立Association的时候有主动的扫描或着被动的扫描两种方式。另外，Beacon还包含了关于Power Save、以及地区等信息。</li><li>Association帧：通常Association帧都有Probe Request和相应的Probe Response。Association的Request中有其所需要的Channel以及Data Rate等状态，以便让AP决定是否让他自己建立Association。而关联是否成功，主要是看Response中Status code是否为Success</li><li><p>Data帧：Data Frame具有方向，这个方向用DS（分布式系统）字段来标识，以区分不同类型帧中关于地址的解析方式；其他的类型Frame例如channel Frame或者管理帧中，这个字段全是零。这个字段用两位表示，这两个位的含义分别表示“To Ds”和“From Ds”，大致含义如下：</p><p> a）To Ds：表示Station -&gt; AP，一般也叫Upload</p><p> b）From Ds：表示AP -&gt; Station，一般也叫Download</p><p> 这里我们大致将DS看作AP，To/From是从AP的角度来考虑的。To DS就是让AP干活。另外Data Frame中还有一个比较重要的字段就是Sequence，表示帧的序号。重传帧序号一样，但是多了一个Retry的字段表示该帧是重传的。</p><p> 为了便于理解，这里再次详细解释一下DS字段的含义：</p><p> To DS=0,From DS=0：表示Station之间的AD Hoc类似的通信，或者控制帧、管理帧。</p><p> To DS=0,From DS=1：Station接受的帧。</p><p> To DS=1,From DS=0：Station发送的帧。</p><p> To DS=1,From DS=1：无线桥接器上的数据帧。</p><p> 这里，我们主要关注To DS和From DS分别是01和10的情况，DS虽然大致等于AP但是它不是AP，它其实是一个系统，从Station的角度来看，比较容易理解。并且To DS和From DS一定是无线网络上面数据帧才有的字段</p></li></ol><h2 id="帧和大端小端"><a href="#帧和大端小端" class="headerlink" title="帧和大端小端"></a>帧和大端小端</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Wi-Fi </tag>
            
            <tag> 无线基础知识 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手机WI-FI信号采集网络的设计与实现</title>
      <link href="/2018/12/28/%E6%89%8B%E6%9C%BAWI-FI%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/12/28/%E6%89%8B%E6%9C%BAWI-FI%E4%BF%A1%E5%8F%B7%E9%87%87%E9%9B%86%E7%BD%91%E7%BB%9C%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="手机WI-FI信号采集网络的设计与实现"><a href="#手机WI-FI信号采集网络的设计与实现" class="headerlink" title="手机WI-FI信号采集网络的设计与实现"></a>手机WI-FI信号采集网络的设计与实现</h1><p>@(VPR)[信号采集|Wi-Fi|网络|手机|大学本科毕业设计]</p><p><strong>XXXX</strong>是一种基于Esp8266开发模块的信号采集设备，其利用现代物联网热潮下的硬件亮点：“轻巧”和“灵活”两大特点为大范围采集信号奠定基础，通过探针数据的提取和mesh网络技术达到收集信号的效果，特点概述：</p><ul><li><strong>使用方便</strong> ：通过预先设置的采集算法，只要用户为设备提供电源即可；</li><li><strong>部署灵活</strong> ：通过Mesh网络的构建，可以实现轻便、高效的接力数据传输；</li><li><strong>适用性高</strong> ：采用mqtt协议，实现了数据在高延迟/带宽优先的网络上的传输；</li><li><strong>成本低廉</strong> ：Esp8266开发板本身的物理硬件成本低廉，；</li></ul><p>作者：战权海   联系方式：<a href="mailto:1137288942@qq.com" target="_blank" rel="noopener">1137288942@qq.com</a>  开始时间：2018年10月2日</p><p><strong>项目说明：</strong><br>本项目起源于学校本身的SRT，后将项目中的信号采集网络部分拆分出来作为毕业设计模块，因此会首先更新WI-FI信号采集网络部分，正巧也是该项目中的第一部分，也是最基础，最基层的部分，该项目的好坏直接影响着后续工作的发展。</p><p><strong>更新在2018年11月10日</strong><br>根据导师前段时间的介绍交流，对项目情况作出如下了解：<br>1.该采集网络要基于esp8266开发板，其资料主要参考乐鑫公司产品说明<br>2.已采购四博智联的断网神器、Wi-Fi探针普通版及http上传版，准备采集源码随后进行分析<br>3.已采购W32集成开发板，着手在空板子上实行代码<br>4.该网络主要基于mqtt网络协议</p><pre><code>并于当日撰写开题报告</code></pre><p><strong>更新在2018年11月17日</strong><br>由于上周一直在忙着考试复习，没有时间关注毕设的事情，下周二要进行开题答辩，因此要进行好好准备</p><p><strong>更新在2018年11月27日</strong><br>最近一直在忙于CTF比赛，今天终于有时间静下心来好好研究项目，但是一上来就被卡住，使用Arduino开发的并不是十分顺利，使用数据线连接到电脑上，使用esptool就可以进行烧写，但是没搞懂要把程序写在哪里，使用Arduino IDE进行开发时，代码始终不能上传，很头疼，不知道怎么处理</p><p><strong>更新在2018年12月28日</strong><br>一晃又过了一个月，这个项目的进展程度确实特别的小，1月13日就要进行阶段性检查，还蛮头疼的。好在上周发现好像是esp板子型号的问题，自己重新采购了一块esp8266，昨天一次性就烧录成功。接下来要做的就是进行简单的开发，具体的mesh网络与mqtt源码已经在github上search到了，要好好学习一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
            <tag> Wi-Fi信号采集 </tag>
            
            <tag> Iot开发 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018网络安全攻防演练</title>
      <link href="/2018/12/27/2018%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/"/>
      <url>/2018/12/27/2018%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2%E6%BC%94%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>周六当晚接到的学院通知，匆匆忙忙回去请假，周天就要报道入住，了解了规则后，觉得这次活动的成长肯定会不少，毕竟不是比赛，没有那么大的压力，从头至尾的保密工作还是比较严格的。当然，这篇文章中不会透露任何过程中涉及的内容，仅是我个人的体会与技术分享。（ps.可能会比较枯燥）</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="我的演练过程"><a href="#我的演练过程" class="headerlink" title="我的演练过程"></a>我的演练过程</h2><p>此次活动主要是以实战网络攻击为主，依靠的是漏洞挖掘与内网渗透的技能。如果平时大佬们挖src比较多或者有很多实战经验的话应该会很得心应手。</p><p>起初的思路有点问题，想依照这awd的模式进行批量攻击，先简要过滤出可能存在的网站，然后再逐个细致挖掘。但这样操作的话，效率十分低下，扫描器的效能问题先搁置不提，单单对一个可能存在漏洞的网站进行挖掘就已经很费时间了，更不要提利用。</p><p>这里说明下，实战不同于src，讲究更多的是利用，而不是发现漏洞。举个例子，在src挖掘过程中，证明某个网站存在sql注入漏洞可以注出数据，拖库是件很了不得的事情，但在实战中，你需要注出管理员的用户名与密码，登陆进去查看能获得什么重要类型的数据，以此来表示该漏洞的威胁程度。</p><p>因此在最开始的一段时间，没有头绪，仅仅是在主域名下不断查找可能存在的漏洞点。随后初见雏形，在某个门户网站下发现了很多的管理系统，开始尝试弱口令的爆破，也是就凭着这三板斧，拿下了几个后台。但后续的利用方式显得十分鸡肋，找到了文件上传的点，但是在上传、连接的过程中经验不足，没能成功getshell。</p><p>最后面的两天基本上没能拿下啥重要的网站，一方面是自己做这方面的经验太少了，另外也是技术不够扎实不够娴熟。</p><h2 id="与大佬的经验交流"><a href="#与大佬的经验交流" class="headerlink" title="与大佬的经验交流"></a>与大佬的经验交流</h2><p>过程中，认识几位从事这方面的牛人，成绩也是十分靠前，经过交流也是学到了很多东西</p><p>在做攻击的过程中，信息搜集的部分永远都应该是花的时间最长而且最为细致的一个，这一环节在做的主要就是进行打击面的拓宽。利用搜索引擎的site、ip等功能尽可能多的获取到同源的网站。最后利用nmap进行端口的扫描，总能在其中发现一些纰漏。这样下去再进行子域名的爬去，攻击面就得到了指数级的增长。可以这样来算，同样利用弱口令，我真对一个网站只有一次攻击机会，对方经过攻击面的拓展，在同一台主机下发现了100个旁站，那么对于他拿下这台主机的次数就增加了100次。效果可想而知。</p><p>还有就是平时经验的积累，怎样绕过waf、利用怎样的文件后缀可以上传小码、大码到服务器上，怎样通过host文件过狗，这都需要长时间的经验积累，一眼就能识别编辑器的类型，想到最近爆出的某某漏洞，从而加以利用。</p><p>自动化工具，批量化工具固然好用，但是在真实的网络战场上，是不容许你去进行多次尝试的，甚至没有第二次机会。因为身为网站的维护着也不是吃素的，也是会搭载些检测警报系统与安全防护系统的。</p><p>最重要的一点写在这里，现如今网络安全法已经出台有几年了，各位师傅们大佬们还是要谨言慎行，平时开开玩笑就好了，别真的搞出来事情，敲几下键盘是小事，给别人造成麻烦与损失进了局子可就不简单了。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我自认为自己入门网络安全也就刚刚一年，才疏学浅，还是很菜的，更多的时间都是在接触CTF竞赛，经过这两次的awd与实战演练，原来CTF也仅仅只是个入门。它更多的是将条件为你构造清楚，选手们去利用各种骚操作进行绕过。但在实战环境中，往往最为基础，最为简单的手法会发现更为严重的漏洞，基础和入门固然重要，小白们也请不要局限于此，专注了眼前的树叶却没看见正片森林。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 实战 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018安恒杯十二月月赛-部分WriteUp</title>
      <link href="/2018/12/22/2018%E5%AE%89%E6%81%92%E6%9D%AF%E5%8D%81%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9B-%E9%83%A8%E5%88%86WriteUp/"/>
      <url>/2018/12/22/2018%E5%AE%89%E6%81%92%E6%9D%AF%E5%8D%81%E4%BA%8C%E6%9C%88%E6%9C%88%E8%B5%9B-%E9%83%A8%E5%88%86WriteUp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>早早的就报了名，可惜今天满课，只有中午和下午4点之后的时间打了一下比赛，pwn题是战队的大佬帮忙出的，听说蛮简单的，等Peanuts大佬更新出WriteUp我再更新学习下。总的来说月赛的题目难度较小，比较适合新手入门。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="学习资料"><a href="#学习资料" class="headerlink" title="学习资料"></a>学习资料</h3><p>解压题目包，给出了两个文件</p><pre><code>-备忘录.txt-只要学不死就往死里学.zip</code></pre><p>通过解压软件可以看到在zip包中也存在“备忘录.txt“<br>这样的话，必然是已知明文攻击了</p><p><a href="http://www.cnblogs.com/leixiao-/p/9824557.html" target="_blank" rel="noopener">zip的各种攻击方式</a></p><p>这样就可以获得破解密码 <strong>1qazmko098</strong></p><p>解压得到了一个word文件</p><pre><code>-学习资料.docx</code></pre><p><img src="https://i.imgur.com/KxfXS1P.jpg" alt=""></p><p>参考这其中的方法 <a href="https://blog.csdn.net/DRondong/article/details/79322799" target="_blank" rel="noopener">word隐写方法</a></p><p>移动图片就能看到flag</p><p><img src="https://i.imgur.com/NwgyFtX.jpg" alt=""></p><h3 id="JUJU"><a href="#JUJU" class="headerlink" title="JUJU"></a>JUJU</h3><p>直接解压出一个损坏的png文件</p><pre><code>-juju.png</code></pre><p>因此先使用010editor修复下</p><p>直接跑png模板就能将CRC校验值修改过来，从而能正常打开图片</p><p>题目中提示有11只猪，但明显图片上的数目不够，因此考虑是不是要修改图片长度</p><p><a href="https://blog.csdn.net/persist213/article/details/79374914" target="_blank" rel="noopener">misc中的png隐写</a></p><p>从中可以了解到，png的宽度是不可以更改的，但是长度可以进行修改，因此稍微将长度加大，就可以在下文中看到字符串</p><p><img src="https://i.imgur.com/nq8lv5n.jpg" alt=""></p><pre><code>MZWGCZ33GQZTQMTEM5SGMMTEPU=====</code></pre><p>显然不是base64（base64最多只能有两个=）</p><p>因此考虑尝试其他base编码，经过base32解码后能看到flag</p><p><img src="https://i.imgur.com/7dpWJxF.png" alt=""></p><p>按要求将{}中的字符串md5后就是最后的答案</p><h2 id="Blockchain"><a href="#Blockchain" class="headerlink" title="Blockchain"></a>Blockchain</h2><h3 id="CoinFlip"><a href="#CoinFlip" class="headerlink" title="CoinFlip"></a>CoinFlip</h3><p>我也是第一次接触区块链的题目，也是听说晚上有原题，就搜了下然后进行了复现</p><p><a href="https://www.secpulse.com/archives/73682.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/73682.html</a></p><p><a href="http://foreversong.cn/archives/1295" target="_blank" rel="noopener">http://foreversong.cn/archives/1295</a></p><p><a href="https://remix.ethereum.org/" target="_blank" rel="noopener">https://remix.ethereum.org/</a></p><p>将.sol文件直接拖进去，按照</p><p><a href="https://www.linkedbyx.com/taskinfo/368/detail" target="_blank" rel="noopener">https://www.linkedbyx.com/taskinfo/368/detail</a></p><p>文章里的操作步骤进行复现</p><p>要注意找好对应的版本</p><p><img src="https://i.imgur.com/oFziHrn.jpg" alt=""></p><p><img src="https://i.imgur.com/78xqDhM.jpg" alt=""></p><p>最后就能到邮件中收到flag</p><p>flag{e0a8634dbb9bd36581a65ca00e2ca886}</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>凑巧今天并列第三名，拿了10w积分，才知道原来安恒的奖励力度这么高（我才不是为了奖励…）这样的话，还是要多参加一下的哈哈哈哈。写的不够到位，各位大佬可以发邮件批评指正，邮箱就在头像下方呦！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 安恒月赛 </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Crypto Task 1</title>
      <link href="/2018/12/21/Crypto-Task-1/"/>
      <url>/2018/12/21/Crypto-Task-1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>也是采取任务发布的形式，每周保证上交一次任务完成报告，组织一次在线交流，通过积分制来进行最后的评测，昨天是第一次任务的截止时间，效果上并不理想，看今晚在线交流的情况再做调整。如果不愿意花时间去学习，是永远出不来成绩的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>本次任务选取的是Cryptopal的Set1.1-1.3，难度很小，适合入门，编程小白稍微花点时间就应该可以看的懂。另外，附上“南宁市网络安全竞赛“的两道密码题。</p><h2 id="Set-1"><a href="#Set-1" class="headerlink" title="Set 1"></a>Set 1</h2><h3 id="Challenge-1"><a href="#Challenge-1" class="headerlink" title="Challenge 1"></a>Challenge 1</h3><p><img src="https://i.imgur.com/jiQrNFF.jpg" alt=""><br>挑战1 目的是将十六进制（hex）进行base64加密<br>所给的字符串为</p><pre><code>49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d</code></pre><p>经过base64后的输出应为</p><pre><code>SSdtIGtpbGxpbmcgeW91ciBicmFpbiBsaWtlIGEgcG9pc29ub3VzIG11c2hyb29t</code></pre><hr><p><strong>新手不要依赖于在线网站和工具！！！这不利于理解原理并掌握其思想，若你想做一个无脑的脚本小子，那么请继续吧！</strong></p><p>重所周知anaconda中已经集成好了很多模块，其中就包括base64，直接import就好</p><p><strong>exp1</strong></p><pre><code># -*- coding: UTF-8 -*-import base64string_hex = &apos;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&apos;# 将十六进制编码的字符进行解码string = string_hex.decode(&apos;hex&apos;)print string# 进行base64加密string_base = base64.b64encode(string)print &apos;result :&apos; + string_base</code></pre><p>具体的细节操作要自己写一遍，细细体会编程中要注意的地方，怎样更贴近人意</p><p><strong>进一步加强</strong></p><p>上述代码还是不能让我们很好的理解base64的过程，因此可以进一步扩展去了解下base64，然后自己写一个本地的base64模块。</p><p><a href="http://www.cnblogs.com/diligenceday/p/6002382.html" target="_blank" rel="noopener">base64详解</a></p><p><strong>local_base64.py</strong></p><pre><code># -*- coding: UTF-8 -*-import stringbase64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + &apos;+/&apos;def encode(string):    base64_bin = [&apos;{:0&gt;8}&apos;.format(str(bin(ord(b))).replace(&apos;0b&apos;, &apos;&apos;)) for b in string]    result = &apos;&apos;    nums = len(base64_bin) // 3    remain = len(base64_bin) % 3    integral_part = base64_bin[0:3 * nums]    while integral_part:        tmp_part = &apos;&apos;.join(integral_part[0:3])        tmp_part = [int(tmp_part[x: x + 6], 2) for x in [0, 6, 12, 18]]        result += &apos;&apos;.join([base64_charset[i] for i in tmp_part])        integral_part = integral_part[3:]    if remain:        remain_part = &apos;&apos;.join(base64_bin[3 * nums:]) + (3 - remain) * &apos;0&apos; * 8        tmp_part = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]        result += &apos;&apos;.join([base64_charset[i] for i in tmp_part]) + (3 - remain) * &apos;=&apos;    return resultdef decode(string):    if not valid_base64_str(string):        return &apos;&apos;    base64_bin = [&apos;{:0&gt;6}&apos;.format(str(bin(base64_charset.index(s))).replace(&apos;0b&apos;, &apos;&apos;)) for s in string if s != &apos;=&apos;]    result = &apos;&apos;    nums = len(base64_bin) // 4    remain = len(base64_bin) % 4    integral_part = base64_bin[0:4 * nums]    while integral_part:        tmp_unit = &apos;&apos;.join(integral_part[0:4])        tmp_unit = [int(tmp_unit[x: x + 8], 2) for x in [0, 8, 16]]        result += &apos;&apos;.join([chr(i) for i in tmp_unit])        integral_part = integral_part[4:]    if remain:        remain_part = &apos;&apos;.join(base64_bin[nums * 4:])        tmp_unit = [int(remain_part[i * 8:(i + 1) * 8], 2) for i in range(remain - 1)]        result += &apos;&apos;.join([chr(i) for i in tmp_unit])    return resultdef valid_base64_str(b_str):    if len(b_str) % 4:        return False    for m in b_str:        if m not in base64_charset + &apos;=&apos;:            return False    return Trueif __name__ == &apos;__main__&apos;:    s = &apos;ABC&apos;    s_encode = encode(s)    s_decode = decode(s_encode)    print s_encode    print    print s_decode</code></pre><p><strong>exp2</strong></p><pre><code># -*- coding: UTF-8 -*-import local_base64string_hex = &apos;49276d206b696c6c696e6720796f757220627261696e206c696b65206120706f69736f6e6f7573206d757368726f6f6d&apos;string = string_hex.decode(&apos;hex&apos;)print stringstring_base = local_base64.encode(string)print &apos;result :&apos; + string_base</code></pre><p>经过challenge1应该就能够对base64有一个很详细的了解了，还是要自己亲身尝试下才能真正掌握并转化成自己的东西。</p><h3 id="Challenge-2"><a href="#Challenge-2" class="headerlink" title="Challenge 2"></a>Challenge 2</h3><p><img src="https://i.imgur.com/GRIqD3Y.jpg" alt=""></p><p>挑战2 目的是让你编写一个函数，使得当你输入</p><pre><code>1c0111001f010100061a024b53535009181c</code></pre><p>让上述字符串，与下列字符串进行异或（XOR）运算</p><pre><code>686974207468652062756c6c277320657965</code></pre><p>得到的结果应该为</p><pre><code>746865206b696420646f6e277420706c6179</code></pre><hr><p>只需要进行一个异或运算，感觉起来应该不难，让我们先来了解下XOR运算操作</p><p><a href="https://blog.csdn.net/xiaopihaierletian/article/details/78162863" target="_blank" rel="noopener">逻辑运算详解</a></p><p>通过上述运算原理的介绍，可以看出这道题目就是等长度异或，实现起来很容易</p><p><strong>exp</strong></p><pre><code># -*- coding: UTF-8 -*-string_hex = &apos;1c0111001f010100061a024b53535009181c&apos;string = int(string_hex,16)string_xor = &apos;686974207468652062756c6c277320657965&apos;string_xor = int(string_xor,16)string_result = string ^ string_xorstring_result = hex(string_result)print &apos;result :&apos; + string_result[2:-1]</code></pre><h3 id="Challenge-3"><a href="#Challenge-3" class="headerlink" title="Challenge 3"></a>Challenge 3</h3><p><img src="https://i.imgur.com/hkCqCx1.jpg" alt=""></p><p>挑战3 题意是给定的下列字符串</p><pre><code>1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736</code></pre><p>是明文与某个单字符异或得到的，让我们找到密钥，并解密出明文的内容</p><p>可以手工完成，但请不要：请编写代码完成</p><hr><p>既然是编写函数，那必然要了解python中的def</p><p><a href="https://www.cnblogs.com/derezzed/articles/8119592.html" target="_blank" rel="noopener">python中的def</a></p><p>先不考虑评分标准，要先找到那个单字符<br>回想一下ascii码中一共有256个，虽然一个一个尝试对于人来说比较缓慢，但对于计算机来说应该不到一秒钟的事。所以这里决定来进行遍历尝试，也就是俗称的“暴力破解”</p><p><strong>暴力破解模块</strong></p><pre><code>def brute(string_xor):    score_pre = 0    for i in range(128):        result = &apos;&apos;        for j in re.findall(&apos;.{2}&apos;,string_xor):            k = int(j,16)            r = chr(i ^ k)            result += r</code></pre><p>这样的话，256种结果都会被存储到result中，接下来解决打分的问题，只需要对每个result进行个测评，然后比较下输出最高的就好了。</p><p><strong>exp</strong></p><pre><code># -*- coding: UTF-8 -*-import restring_xor = &apos;1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736&apos;def judge(s):    score_tmp = 0    freqs = {&apos;a&apos;:0.0651738,&apos;b&apos;:0.0124248,&apos;c&apos;:0.0217339,&apos;d&apos;:0.0349835,         &apos;e&apos;:0.1041442,&apos;f&apos;:0.0197881,&apos;g&apos;:0.0158610,&apos;h&apos;:0.0492888,         &apos;i&apos;:0.0558094,&apos;j&apos;:0.0009033,&apos;k&apos;:0.0050529,&apos;l&apos;:0.0331490,         &apos;m&apos;:0.0202124,&apos;n&apos;:0.0564513,&apos;o&apos;:0.0596302,&apos;p&apos;:0.0137645,         &apos;q&apos;:0.0008606,&apos;r&apos;:0.0497563,&apos;s&apos;:0.0515760,&apos;t&apos;:0.0729357,         &apos;u&apos;:0.0225134,&apos;v&apos;:0.0082903,&apos;w&apos;:0.0171272,&apos;x&apos;:0.0013692,         &apos;y&apos;:0.0145984,&apos;z&apos;:0.0007836,&apos; &apos;:0.1918182         }    for x in s.lower():        if x in freqs:            score_tmp += freqs[x]    return score_tmpdef brute(string_xor):    score_pre = 0    for i in range(128):        result = &apos;&apos;        for j in re.findall(&apos;.{2}&apos;,string_xor):            k = int(j,16)            r = chr(i ^ k)            result += r        score = judge(result)        if score &gt; score_pre:            score_pre = score            final = result            key = chr(i)    return final,keyfinal,key = brute(string_xor)print finalprintprint key</code></pre><p>这里是字母采用频率的方法进行测评，python3中带有wordfreq模块直接可以查取字符频率，无奈使用的是python2，只能采用其他人收集的频率情况。</p><h2 id="南宁市网络安全技术大赛（Crypto）"><a href="#南宁市网络安全技术大赛（Crypto）" class="headerlink" title="南宁市网络安全技术大赛（Crypto）"></a>南宁市网络安全技术大赛（Crypto）</h2><p>writeup分享者：Mengmeng</p><h3 id="维吉尼亚遇上困难"><a href="#维吉尼亚遇上困难" class="headerlink" title="维吉尼亚遇上困难"></a>维吉尼亚遇上困难</h3><p>密文：<br>BZGTNPMMCGZFPUWJCUIGRWXPFNLHZCKOAPGLKYJNRAQFIUYRAVGNPANUMDQOAHMWTGJDXGOMPJPTKAAVZIUIWKVTUCWBWNFWDFUMPJWPMQGPTNWXTSDPLPMWJAXUHHXWPFXXGVAPFNTXVFKOYIRBOQJHCBVWVFYCGQFGUSUBDWVIYATJGTBNDKGHCTMTWIUEFJITVUGJHHIMUVJICUWYQWYGGUWPUUCWIFGWUANILKPHDKOSPJTTWJQOJHXLBJAPZHVQWPDYPGLLGDBCHTGIZCCMEGVIIJLIFFBHSMEGUJHRXBOQUBDNASPEUCWNGWSNWXTSDPLPMWJAIUHUMWPSYCTUWFBMIAMKVBNTDMQNBVDKILQSSDYVWVXIGDQFIBHSLEAVDBXGOLGDBCHTGIZVNFQFKTNGRWXUDCTGKWCOXIXKZPPFDZGXNBAXLGGWBLTLWCKOXAR</p><p>题目已经给出很明显的提示了，是维吉尼亚密码，根据密文的长度，可以确定是想让我们进行无密钥破解维吉尼亚密码，原理如下：</p><p><a href="https://blog.csdn.net/limisky/article/details/16885959" target="_blank" rel="noopener">维吉尼亚密码及其破解原理</a></p><p>用github上的工具，跑一下,得到flag<br><img src="https://i.imgur.com/QMFAvbz.png" alt=""></p><p><a href="https://atomcated.github.io/Vigenere/" target="_blank" rel="noopener">维吉尼亚无密钥破解工具</a></p><p>该工具可以直接下载下来，部署到本地</p><p>flag:{YOU ARE SO KINDLY}</p><h3 id="shamir重要数据损坏"><a href="#shamir重要数据损坏" class="headerlink" title="shamir重要数据损坏"></a>shamir重要数据损坏</h3><p>该题目考查的是Shamir秘密共享算法</p><p> <img src="https://i.imgur.com/KyHYt6N.png" alt=""></p><p> 大概了解了之后用题目给的信息进行计算<br> <img src="https://i.imgur.com/INN4jMu.png" alt=""></p><p> X1=5，X2=7，X3=9</p><p>（X_1,f(X_1)）=(5,2258)</p><p>（X_2,f(X_2)）=(7,2424)</p><p>（X_3,f(X_3)）=(9,2630)</p><hr><p>a0+a_1 x_1+a_2 x_1^2=2258</p><p>a0+a_1 x_2+a_2 x_2^2=2424</p><p>a0+a_1 x_3+a_2 x_3^2=2630</p><p>代入x1,x2,x3,经计算可得a0=2018，a1=23,a2=5<br>所以s=a0=2018<br>flag：{2018}</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>对于小白来讲，可能会觉得这些东西有点晦涩。但我想说的是，这仅仅只是个入门，至今为止我都坚信一万个小时定律，这段时间的锤炼是让你从平凡变成大师的过程，若是能踏踏实实走完，想必你不会后悔，我会伴随你们一同前行，加油我们的信安之路！</p>]]></content>
      
      
      
        <tags>
            
            <tag> Crypto </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello my New World</title>
      <link href="/2018/12/20/Hello-my-New-World/"/>
      <url>/2018/12/20/Hello-my-New-World/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天给萌萌尝试着搭建了这个博客，花了差不多半天的时间，部分功能还没调试完成，总的来说界面很清新，我倒是蛮喜欢的。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>这次更新了之后，就应该不会再进行大的变动了，也是时隔一段时间没有更新博客了。<br>原因是前一段时间满课，周末在忙着比赛，基本上是天天加班，顺着带着也记录下这段时间的经历吧</p><p>“领航杯”之后应该一直都是满课的，从早上到晚。对于课程的安排我反正是无力吐槽了，身为一名大四的信安专业学生，却在课堂上一点专业知识都学不到。</p><p>“东华杯”的线上赛发挥还是挺好的，拿下了一道密码二血，跟着蒋师傅把战队总到了决赛，可惜决赛那周周末比赛较多，少了一次线下比赛的机会。转身去打了X-nuca全国高校联赛。</p><p>X-nuca是在厦门打的，是作为“博鹭杯”同行去厦门的，虽说是同行不用上场，但X-nuca的线上同样至关重要，只有我和蒋师傅两个人参加，可以说线上打得是十分难受了，从头至尾我这个密码+三流web手只解出了一道题目，最后还是靠着徐教员的帮忙，才挺进了决赛。还是自己太菜了。。</p><p>“鹏城杯”的线上赛还是蛮轻松的，密码题拿了个一血，misc和web也是在何师傅的指导下出了几道题目，最后凭着一个不错的名次进入了决赛</p><p>X-nuca和“鹏城杯”的线下赛是我今年成长最大的一次。也正是这两场比赛真正地打醒了我这只菜鸡。。满场纷飞的pwn题打得我没脾气。由于主办方的失误有幸让我们提前拿到了源码，虽说分析了一波写出了exp，但在服务器上线的时候，瞬间就被打到绝望。</p><p>赛后打听到，牛*的大佬队伍都是本地跑好了连接ssh，down源码的脚本，就算单身二十年的手速同样是追不上计算机的脚步啊。。。跟神仙们的差距太大了，不论是思路还是技术都很落后，现在早已不是闭关修炼二十年出山就能当老大的时代了。</p><p>本事是自己的，我不甘心做一只井底之蛙。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> daily </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
